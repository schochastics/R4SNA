library(ggraph)
data("ht_advice")
data("ht_friends")
data("ht_reports")
ht_advice
ht_friends
ht_reports
reciprocity(ht_advice)
reciprocity(ht_friends)
reciprocity(ht_reports)
dyad_census(ht_advice)
str(ht_advice)
dyad_census(ht_advice)
45/190
90/190
reciprocity(ht_advice)
triad_census(ht_advice)
library(sna)
library(intergraph)
as.network(ht_advice)
asNetwork(ht_advice)
sna::triad.census(asNetwork(ht_advice))
sna::triad.census(ht_advice)
sna::triad.census(asNetwork(ht_advice))
sna::triad.census(asNetwork(ht_reports))
sna::triad.census(asNetwork(ht_advice))
sna::triad.census(asNetwork(ht_reports))
sna::triad.census(asNetwork(ht_friends))
data("flo_marriage")
data("flo_business")
?degree()
igraph::degree(flo_marriage)
igraph::betweenness(flo_marriage)
igraph::closeness(flo_marriage)
igraph::eigenvector(flo_marriage)
igraph::eigen_centrality(flo_marriage)
round(igraph::eigen_centrality(flo_marriage)$vector)
round(igraph::eigen_centrality(flo_marriage)$vector, 2)
data("southern_women")
southern_women
A <- as_biadjacency_matrix(southern_women)
A
women <- A%*%t(A)
women
dates <- t(A)%*%A
dates
women1[women>3]
women[women>3]
ggraph(proj1,"stress")+
geom_edge_link(aes(edge_width=weight),edge_color="grey66",show.legend = FALSE)+
geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
geom_node_text(aes(label=name))+
scale_edge_width(range = c(1,4))+
theme_void()+
coord_cartesian(clip = "off")
ggraph(proj1,"stress")+
geom_edge_link(aes(edge_width=weight),edge_color="grey66",show.legend = FALSE)+
geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
geom_node_text(aes(label=name))+
scale_edge_width(range = c(1,4))+
theme_void()+
coord_cartesian(clip = "off")
proj1 <- graph_from_adjacency_matrix(women, weighted = TRUE,diag = FALSE,mode = "undirected")
ggraph(proj1,"stress")+
geom_edge_link(aes(edge_width=weight),edge_color="grey66",show.legend = FALSE)+
geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
geom_node_text(aes(label=name))+
scale_edge_width(range = c(1,4))+
theme_void()+
coord_cartesian(clip = "off")
ggraph(proj1,"stress")+
geom_edge_link(aes(edge_width=weight==4),edge_color="grey66",show.legend = FALSE)+
geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
geom_node_text(aes(label=name))+
scale_edge_width(range = c(1,4))+
theme_void()+
coord_cartesian(clip = "off")
proj2 <- graph_from_adjacency_matrix(dates, weighted = TRUE,diag = FALSE,mode = "undirected")
ggraph(proj2,"stress")+
geom_edge_link(aes(edge_width=weight),edge_color="grey66",show.legend = FALSE)+
geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
geom_node_text(aes(label=name))+
scale_edge_width(range = c(1,4))+
theme_void()+
coord_cartesian(clip = "off")
library(statnet)
library(igraph)
library(ggraph)
library(intergraph)
library(patchwork)
library(networkdata)
data(coleman, package = "sna")
coleman
fall_mat <- coleman[1,,]
fall_mat
dim(coleman)
rowsum(fall_mat)
rowSum(fall_mat)
rowSums(fall_mat)
colSums(fall_mat)
rowSums(fall_mat) == colSums(fall_mat)
sum(rowSums(fall_mat))
sum(colSums(fall_mat))
fall_g <- graph_from_adjacency_matrix(fall_mat, "directed")
fall_g
snahelper:::SNAhelperAddin()
fall_p <- ggraph(fall_g , layout = "nicely") +
geom_edge_link(edge_colour = "#666060", end_cap = circle(9,"pt"),
n = 2, edge_width = 0.4, edge_alpha = 1,
arrow = arrow(angle = 15,
length = unit(0.1, "inches"),
ends = "last", type = "closed"))  +
geom_node_point(fill = "#525252",colour = "#FFFFFF",
size = 5, stroke = 1.1, shape = 21) +
theme_graph() +
ggtitle("fall friendship network") +
theme(legend.position = "none")
fall_p
fall_p <- ggraph(fall_g , layout = "nicely") +
geom_edge_link(edge_colour = "#666060", end_cap = circle(9,"pt"),
n = 2, edge_width = 0.4, edge_alpha = 1,
arrow = arrow(angle = 15,
length = unit(0.1, "inches"),
ends = "last", type = "closed"))  +
geom_node_point(fill = "#525252",colour = "#FFFFFF",
size = 5, stroke = 1.1, shape = 21) +
theme_graph() +
ggtitle("fall friendship network") +
theme(legend.position = "none")
fall_p
snahelper:::SNAhelperAddin()
sum(fall_mat)/(dim(fall_mat)[1]*(dim(fall_mat)[1]-1))
density(fall_g)
density(fall_g)
?density
igraph::density(fall_g)
edge_density(fall_g)
dim(fall_mat)
sum(fall_mat)/(dim(fall_mat)[2]*(dim(fall_mat)[1]-1))
?rgraph
dim(fall_mat)[1]
sim1_mat <- rgraph(n = dim(fall_mat)[1], m = 1,
tprob = edge_density(fall_g), mode = "digraph")
sim1_mat <- rgraph(n = dim(fall_mat)[1], m = 1,
tprob = edge_density(fall_g), mode = "digraph")
sim1_mat
sim1_g <- graph_from_adjacency_matrix(sim1_mat, "directed")
sim1_g
sum(sim1_mat)
set.seed(1234)
sim1_mat <- rgraph(n = dim(fall_mat)[1], m = 1,
tprob = edge_density(fall_g), mode = "digraph")
sim1_g <- graph_from_adjacency_matrix(sim1_mat, "directed")
sum(sim1_mat)
edge_density(fall_g)
edge_density(sim1_g)
fall_p + sim1_p # 'patchwork' required for this
sim1_p <- ggraph(sim1_g, layout = "nicely") +
geom_edge_link(edge_colour = "#666060",
end_cap = circle(9,"pt"), n = 2,
edge_width = 0.4, edge_alpha = 1,
arrow = arrow(angle = 15,
length = unit(0.1, "inches"),
ends = "last", type = "closed"))  +
geom_node_point(fill = "#525252", colour = "#FFFFFF",
size = 5, stroke = 1.1, shape = 21) +
theme_graph() +
ggtitle("random network") +
theme(legend.position = "none")
fall_p + sim1_p #
?rgnm
library(statnet)
library(igraph)
library(ggraph)
library(intergraph)
library(patchwork)
library(networkdata)
data("law_friends")
law_friends
law_mat.frn <- as_adjacency_matrix(law_friends, sparse = FALSE)
law_mat.frn
dim(law_mat.frn)[1]
dim(law_mat.frn)[2]
sum(law_mat.frn)
vertex_attr(law_friends)$gender
vertex_attr(law_friends)$status
vertex_attr(law_friends)$practice
law_attr.gend <- as.data.frame(vertex_attr(law_friends)$gender)
law_attr.gend
homoph_obs.frn <- sum(law_mat.frn[law_attr.gend == 1, law_attr.gend == 1]) +
sum(law_mat.frn[law_attr.gend == 2, law_attr.gend == 2])
homoph_obs.frn
law_sim1000.frn <- rgnm(1000, law_nodes, law_ties.frn, mode='digraph')
law_nodes <- dim(law_mat.frn)[1]
law_ties.frn <- sum(law_mat.frn)
law_sim1000.frn <- rgnm(1000, law_nodes, law_ties.frn, mode='digraph')
?apply
homoph_sim.frn <- apply(law_sim1000.frn, 1, function(x) {
sum(x[law_attr.gend == 1,law_attr.gend == 1]) +
sum(x[law_attr.gend == 2, law_attr.gend == 2])})
homoph_sim.frn
homoph_sim.frn <- as.data.frame(homoph_sim.frn)
p_lawsim1000.frn <- ggplot(homoph_sim.frn, aes(x= homoph_sim.frn))  +
geom_histogram(binwidth = 5, color="darkgrey", fill="lightgrey") +
coord_cartesian(ylim=c(0,200)) +
labs(title = "", x = "number of homophilious ties")
p_lawsim1000.frn
p_lawsim1000.frn <- ggplot(homoph_sim.frn, aes(x= homoph_sim.frn))  +
geom_histogram(binwidth = 5, color="darkgrey", fill="lightgrey") +
coord_cartesian(ylim=c(0,200)) +
labs(title = "", x = "number of homophilious ties")+
geom_vline(xintercept = homoph_obs.frn , lwd=0.5, colour="red") +
p_lawsim1000.frn
p_lawsim1000.frn <- ggplot(homoph_sim.frn, aes(x= homoph_sim.frn))  +
geom_histogram(binwidth = 5, color="darkgrey", fill="lightgrey") +
coord_cartesian(ylim=c(0,200)) +
labs(title = "", x = "number of homophilious ties")+
geom_vline(xintercept = homoph_obs.frn , lwd=0.5, colour="red")
p_lawsim1000.frn
sum(homoph_sim.frn  > homoph_obs.frn)/1000
data(florentine) # loads flomarriage and flobusiness data
flom_net <- flomarriage # look at the flomarriage network data
flom_mat <- as.matrix(flomarriage)
data(florentine) # loads flomarriage and flobusiness data
flom_g <- asIgraph(flom_net)
flom_p <- ggraph(flom_g, layout = "stress") +
geom_edge_link0(edge_colour = "#666060",
edge_width = 0.8, edge_alpha = 1) +
geom_node_point(fill = "#808080", colour = "#808080",
size = 7, shape = 21, stroke = 0.9) +
theme_graph() +
theme(legend.position = "none") +
geom_node_text(aes(label = vertex.names), colour = "#000000",
size = 5, family = "sans") +
ggtitle("Florentine marriage network")
flom_p
?ergm
flom_net
flom_mod1 <- ergm(flom_net ~ edges) # fit the model
summary(flom_mod1) # get a summary of model
set.seed(1) #include if you want the same results shown here
flom_mod2 <- ergm(flom_net ~ edges + triangle)
flom_mod2 <- ergm(flom_net ~ edges + triangle)
mcmc.diagnostics(flom_mod2)
summary(flom_mod2 )
set.seed(1) #include if you want the same results shown here
flom_mod2 <- ergm(flom_net ~ edges + triangle)
)
source("~/.active-rstudio-document", echo=TRUE)
mcmc.diagnostics(flom_mod2, center = TRUE)
flom_mod2.sim <- simulate(flom_mod2, nsim = 10)
summary(flom_mod2.sim)
flom_mod2.sim[[1]]
flom_mod2.sim[[10]]
flom.sim_g <-asIgraph(flom_mod2.sim[[10]])
flom.sim_p <- ggraph(flom.sim_g, layout = "stress") +
geom_edge_link0(edge_colour = "#666060",
edge_width = 0.8, edge_alpha = 1) +
geom_node_point(fill = "#808080", colour = "#808080",
size = 7, shape = 21, stroke = 0.9) +
theme_graph() +
theme(legend.position = "none") +
ggtitle("Simulated network")
flom.sim_p
flom_mod2.gof <- gof(flom_mod2)
par(mfrow=c(2,2))
plot(flom_mod2.gof)
data("knecht")
dev.off()
data("knecht")
knecht
knecht4_g <- knecht[[4]]
knecht4_mod1 <- ergm(knecht4_net ~ edges + mutual)
knecht4_net <- asNetwork(knecht[[4]])
knecht4_mod1 <- ergm(knecht4_net ~ edges + mutual)
summary(knecht4_mod1)
mcmc.diagnostics(knecht4_mod1)
knecht4_mod1.gof <- gof(knecht4_mod1) # this will produce 4 plots
par(mfrow = c(3,2)) # figure orientation with 2 rows and 2 columns
plot(knecht4_mod1.gof)
knecht4_mod2 <- ergm(knecht4_net ~ edges +  nodecov("gender") +
nodematch("gender") + mutual)
summary(knecht4_mod2)
knecht4_mod2.gof <- gof(knecht4_mod2) # this will produce 4 plots
par(mfrow = c(3,2)) # figure orientation with 2 rows and 2 columns
plot(knecht4_mod2.gof)
plot(knecht4_mod2.gof)
remotes::install_github("schochastics/networkdata")
library(networkdata)
data
datas(glasgow129)
data(glasgow129)
glasgow129
flo_business
?data
?networkdata
str(flo_business)
str(glasgow129)
networkdata::s50
networkdata::s50[[1]]
s50_g <- networkdata::s50[[3]]
s50_net <- asNetwork(s50_g)
library(statnet)
library(intergraph)
library(igraph)
library(ggraph)
library(graphlayouts)
library(networkdata)
library(tidyverse)
s50_net <- asNetwork(s50_g)
s50_net
# Load data as graph object from networkdata and extract all three wave networks
glasgow_g1 <- networkdata::glasgow129[[1]]
glasgow_g2 <- networkdata::glasgow129[[2]]
glasgow_g3 <- networkdata::glasgow129[[3]]
# Convert to network objects using intergraph
glasgow_net1 <- asNetwork(glasgow_g1)
glasgow_net2 <- asNetwork(glasgow_g2)
glasgow_net3 <- asNetwork(glasgow_g3)
# check network obejct and stored attributes
glasgow_net1
glasgow_net2
glasgow_net3
glasgow_array <- array(c(glasgow_net1, glasgow_net2, glasgow_net3),
dim = c(129, 129, 3))
glasgow_array
friendship_network <- sienaNet(glasgow_array)
?sienaNet
saom_data <- sienaDataCreate(friendship_network)
friend_nets <- sienaDependent(glasgow_array)
# Load RSiena
library(RSiena)
friend_nets <- sienaDependent(glasgow_array)
?sienaDependent
glasgow_array <- array(c(glasgow_net1, glasgow_net2, glasgow_net3),
dim = c(129, 129, 3))
friend_nets <- sienaDependent(glasgow_array)
# Load RSiena package
library(RSiena)
# Convert to adjacency matrices if not already
net1 <- as.matrix(as_adjacency_matrix(glasgow_net1, sparse = FALSE))
# Combine into 3D array [actor x actor x wave]
net_array <- array(c(net1, net2, net3), dim = c(129, 129, 3))
# Combine into 3D array [actor x actor x wave]
net_array <- array(c(glasgow_net1, glasgow_net2, glasgow_net3), dim = c(129, 129, 3))
# Convert array into RSiena dependent object
siena_net <- sienaDependent(net_array)
net_array
glasgow_net1
glasgow_g1 <- networkdata::glasgow129[[1]]
glasgow_g2 <- networkdata::glasgow129[[2]]
glasgow_g3 <- networkdata::glasgow129[[3]]
# Convert to adjacency matrices if not already
net1 <- as.matrix(as_adjacency_matrix(glasgow_g1, sparse = FALSE))
net2 <- as.matrix(as_adjacency_matrix(glasgow_g2, sparse = FALSE))
net3 <- as.matrix(as_adjacency_matrix(glasgow_g3, sparse = FALSE))
# Combine into 3D array [actor x actor x wave]
net_array <- array(c(glasgow_net1, glasgow_net2, glasgow_net3), dim = c(129, 129, 3))
net_array
# Convert array into RSiena dependent object
siena_net <- sienaDependent(net_array)
glasgow_g1
glasgow_net1
net1
# Convert to adjacency matrices if not already
net1 <- as.matrix(as_adjacency_matrix(glasgow_g1, sparse = FALSE))
net2 <- as.matrix(as_adjacency_matrix(glasgow_g2, sparse = FALSE))
net3 <- as.matrix(as_adjacency_matrix(glasgow_g3, sparse = FALSE))
# Combine into 3D array [actor x actor x wave]
net_array <- array(c(glasgow_g1, glasgow_g2, glasgow_g3), dim = c(129, 129, 3))
net_array
# Combine into 3D array [actor x actor x wave]
net_array <- array(c(net1, net2, net3), dim = c(129, 129, 3))
net_array
# Convert array into RSiena dependent object
siena_net <- sienaDependent(net_array)
# Step 2: Create a Siena data object
saom_data <- sienaDataCreate(siena_net)
# Step 3: Define the effects
# Start with default effect object
my_effects <- getEffects(saom_data)
# Include two effects: outdegree (density) and reciprocity
my_effects <- includeEffects(my_effects, outdegree, recip)
# Step 4: Create an algorithm object for model estimation
my_algorithm <- sienaAlgorithmCreate(projname = "saom_simple_model")
# Step 5: Estimate the model
saom_model <- siena07(
my_algorithm,
data = saom_data,
effects = my_effects,
batch = TRUE
)
# Step 6: Print the estimation table with standard errors and t-scores
print(summary(saom_model), tstat = TRUE)
set.seed(1234)
saom_model_1 <- siena07(
my_algorithm,
data = saom_data,
effects = my_effects,
batch = TRUE
)
saom_model_1
-2.410 + 2.703
my_algorithm <- sienaAlgorithmCreate(projname = "saom_model_1", seed = 123)
setwd("~/Documents/GitHub/R4SNA/inferential")
saom_model_1 <- siena07(
my_algorithm,
data = saom_data,
effects = my_effects,
batch = TRUE
)
saom_model_1
my_effects <- getEffects(saom_data)
my_effects
net_data <- sienaDataCreate(siena_net)
netdata
net_data
my_effects <- getEffects(net_data)
my_effects
includeEffects(my_effects, outdegree, recip)
-2.411 + 2.705
-2.411 + 2.705
net3
glasgow_g3,
glasgow_g3
sex_vector <- as.numeric(V(glasgow_g1)$sex.F)
sex_vector
V(glasgow_g1)
glasgow_g1
glasgow129
glasgow_g1 <- networkdata::glasgow129[[1]]
glasgow_g1
V(glasgow_g1)$sex.F
V(glasgow129[[1]])$sex.F
V(glasgow_g1)$sex.F
sex <- vertex_attr(glasgow_g1, name = "sex.F")
sex
V(glasgow_g1)$`sex.F`
glasgow_g1
snahelper:::SNAhelperAddin()
snahelper:::SNAhelperAddin()
glasgow129
glasgow129[[1]]
snahelper:::SNAhelperAddin()
g <- glasgow129[[1]]
g
snahelper:::SNAhelperAddin()
g <- glasgow129[[2]]
g
snahelper:::SNAhelperAddin()
as.numeric(V(glasgow_g2)$sex.F)
as.numeric(V(glasgow_g3)$sex.F)
glasgow_g3
V(glasgow_g3)$sex.F
as.numeric(V(glasgow_g3)$sex.F)
# Extract the character vector
sex_char <- V(glasgow_g3)$sex.F
# Recode to numeric: 1 = Female, 0 = Male
sex_num <- ifelse(sex_char == "F", 1,
ifelse(sex_char == "M", 0, NA))
# Check the result
table(sex_num, useNA = "ifany")
# Extract the character vector
sex_char <- V(glasgow_g2)$sex.F
# Recode to numeric: 1 = Female, 0 = Male
sex_num <- ifelse(sex_char == "F", 1,
ifelse(sex_char == "M", 0, NA))
# Check the result
table(sex_num, useNA = "ifany")
sex_char <- V(glasgow_g3)$sex.F
sex_char
sex_cov <- coCovar(sex_num)
sex_cov
smoke1 <- as.numeric(V(glasgow_g1)$familysmoking)
smoke2 <- as.numeric(V(glasgow_g2)$familysmoking)
smoke3 <- as.numeric(V(glasgow_g3)$familysmoking)
smoking_array <- cbind(smoke1, smoke2, smoke3)
smoking_cov <- varCovar(smoking_array)
smoking_cov
mean(sex_cov)
smoking_cov
smoke1
mean(smoke1)
mean(smoke1+smoke2+smoke3)
smoking_cov
mean(smoking_cov)
glasgow_g1
smoking_cov
smoke1 <- as.numeric(V(glasgow_g1)$tobacco)
smoke1
smoking_array
smoke1 <- as.numeric(V(glasgow_g1)$tobacco)
smoke2 <- as.numeric(V(glasgow_g2)$tobacco)
smoke3 <- as.numeric(V(glasgow_g3)$tobacco)
smoking_array <- cbind(smoke1, smoke2, smoke3)
smoking_array
smoking_cov <- varCovar(smoking_array)
smoking_cov
mean(smoking_array)
mean(smoking_cov)
smoking_cov
mean(smoking_cov)
remotes::install_github("schochastics/networkdata")
glasgow_g1 <- networkdata::glasgow129[[1]]
glasgow_g2 <- networkdata::glasgow129[[2]]
glasgow_g3 <- networkdata::glasgow129[[3]]
glasgow_g1
glasgow_g2
V(glasgow_g1)$sex.F
glasgow_g1 <- networkdata::glasgow129[[1]]
glasgow129
V(glasgow_g2)$sex.F
