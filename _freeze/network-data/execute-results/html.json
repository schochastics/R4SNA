{
  "hash": "c02ad332add49afb25487e09b2d84299",
  "result": {
    "engine": "knitr",
    "markdown": "# Network Data {.unnumbered}\n\n## Introduction\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n```\n:::\n\n\n## Definitions\n\n- vertices\n- edges\n\n## Network representations\n\n\n### Adjacency Matrix\n\nAn adjacency matrix is a square matrix where the elements indicate whether pairs of vertices in the graph are adjacent or notâ€”meaning, whether they are directly connected by an edge. If the graph has $n$ vertices, the matrix $A$ will be an $n \\times n$ matrix where the entry $A_{ij}$ is $1$ if there is an edge from vertex $i$ to vertex $j$, and $0$ if there is no edge. In the case of weighted graphs the weight of the edge is used. This matrix is symmetric for undirected graphs, indicating that an edge is bidirectional.  \n\n**Pros:**  \n\n- **Simple Representation**: It provides a straightforward and compact way to represent graphs, especially useful for dense graphs where many or most pairs of vertices are connected.\n\n- **Efficient for Edge Lookups**: Checking whether an edge exists between two vertices can be done in constant time, making it efficient for operations that require frequent edge lookups.\n\n- **Easy Implementation of Algorithms**: Many graph algorithms can be easily implemented using adjacency matrices, making it a preferred choice for certain computational tasks.\n\n**Cons:**  \n\n- **Space Inefficiency**: For sparse graphs, where the number of edges is much less than the square of the number of vertices, an adjacency matrix uses a lot of memory to represent a relatively small number of edges.\n\n- **Poor Scalability**: As the number of vertices grows, the size of the matrix grows quadratically, which can quickly become impractical for large graphs.\n\n### Edge List\n\nAn edge list is a matrix where each row indicates an edge. In an undirected graph, an edge is represented by a pair $(i,j)$, indicating a connection between vertices $i$ and $j$. For directed graphs, the order of the vertices in each pair denotes the direction of the edge, from the first vertex to the second. In weighted graphs, a third column can be added to each pair to represent the weight of the edge.\n\n**Pros:**  \n\n- **Space Efficiency for Sparse Graphs**: Edge lists are particularly space-efficient for representing sparse graphs where the number of edges is much lower than the square of the number of vertices, as they only store the existing edges.\n\n- **Simplicity**: The structure is straightforward and easy to understand, making it suitable for simple graph operations and for initial graph representation before processing.\n\n**Cons:**  \n\n- **Inefficient for Edge Lookups**: Checking whether an edge exists between two specific vertices can be time-consuming, as it may require scanning through the entire list, leading to an operation that is linear in the number of edges.\n\n- **Inefficiency in Graph Operations**: Operations like finding all vertices adjacent to a given vertex or checking for connectivity between vertices can be inefficient compared to other representations like adjacency matrices or adjacency lists, especially for dense graphs.\n\n- **Less Suitable for Dense Graphs**: As the number of edges grows, the edge list can become large and less efficient in terms of both space and operation time compared to an adjacency matrix for dense graphs, where the number of edges is close to the maximum possible number of edges.\n\n### Adjacency List\n\nAn adjacency list is a collection of lists, with each list corresponding to the set of adjacent vertices of a given vertex. This means that for every vertex $i$ in the graph, there is an associated list that contains all the vertices $j$ to which $i$ is directly connected. \n\n**Pros:**  \n\n- **Space Efficiency**: Adjacency lists are more space-efficient than adjacency matrices in sparse graphs, as they only store information about the actual connections.\n\n- **Scalability**: This representation scales better with the number of edges, especially for graphs where the number of edges is far less than the square of the number of vertices.\n\n- **Efficiency in Graph Traversal**: For operations like graph traversal or finding all neighbors of a vertex, adjacency lists provide more efficient operations compared to adjacency matrices, particularly in sparse graphs.\n\n**Cons:**  \n\n- **Edge Lookups**: Checking whether an edge exists between two specific vertices can be less efficient than with an adjacency matrix, as it may require traversing a list of neighbors.\n\n- **Variable Edge Access Time**: The time to access a specific edge or to check for its existence can vary depending on the degree of the vertices involved, leading to potentially inefficient operations in certain scenarios.\n\n- **Higher Complexity for Dense Graphs**: In very dense graphs, where the number of edges approaches the number of vertex pairs, adjacency lists can become less efficient in terms of space and time compared to adjacency matrices, due to the overhead of storing a list for each vertex.\n\n\n## Networks in `igraph`\n \nBelow, we represent friendship relations between Bob, Ann, and Steve as a matrix and an edgelist.\n\n::: {.cell}\n\n```{.r .cell-code}\n# adjacency matrix\nA <- matrix(\n    c(0, 1, 1, 1, 0, 1, 1, 1, 0),\n    nrow = 3, ncol = 3, byrow = TRUE\n)\n\nrownames(A) <- colnames(A) <- c(\"Bob\", \"Ann\", \"Steve\")\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Bob Ann Steve\nBob     0   1     1\nAnn     1   0     1\nSteve   1   1     0\n```\n\n\n:::\n\n```{.r .cell-code}\n# edgelist\nel <- matrix(c(\"Bob\", \"Ann\", \"Bob\", \"Steve\", \"Ann\", \"Steve\"),\n    nrow = 3, ncol = 2, byrow = TRUE\n)\nel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]  [,2]   \n[1,] \"Bob\" \"Ann\"  \n[2,] \"Bob\" \"Steve\"\n[3,] \"Ann\" \"Steve\"\n```\n\n\n:::\n:::\n\n\nOnce we have defined an edgelist or an adjacency matrix, we can turn them into `igraph` objects as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 <- graph_from_adjacency_matrix(A, mode = \"undirected\", diag = FALSE)\n\ng2 <- graph_from_edgelist(el, directed = FALSE)\n# g1 and g2 are the same graph so only printing g1\ng1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH c59236e UN-- 3 3 -- \n+ attr: name (v/c)\n+ edges from c59236e (vertex names):\n[1] Bob--Ann   Bob--Steve Ann--Steve\n```\n\n\n:::\n:::\n\n\nThe printed summary shows some general descriptives of the graph.\nThe string \"UN--\" in the first line indicates that the network is *U*ndirected (*D* for directed graphs) and has a *N*ame attribute (we named the nodes Bob, Ann, and Steve). The third and forth character are *W*, if there is a edge weight attribute, and *B* if the network is bipartite (there exists a node attribute \"type\"). The following number indicate the number of nodes and edges.\nThe second line lists all graph, node and edge variables. Here, we only have a node attribute \"name\". \n\nThe conversion from edgelist/adjacency matrix into an igraph object is quite straightforward. The only difficulty is setting the parameters correctly (Is the network directed or not?), especially for edgelists where it may not immediately be obvious if the network is directed or not.\n\n## Importing Network Data\n\n### Nodes and Ties\n\n### Attributes\n\n### Import via `snahelper`\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}