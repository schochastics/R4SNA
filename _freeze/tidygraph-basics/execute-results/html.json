{
  "hash": "760ef5507d2b12328713bf08b121e092",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n\n\n\n# Basics of tidygraph\n\n## Graph structures\nWe'll use the famous Florentine Family marriage dataset as a running example. The\ndataset is in `igraph` format but can be converted to a `tbl_graph` object with \n`as_tbl_graph()`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"flo_marriage\")\nflo_tidy <- as_tbl_graph(flo_marriage)\nflo_tidy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tbl_graph: 16 nodes and 20 edges\n#\n# An undirected simple graph with 2 components\n#\n# Node Data: 16 × 4 (active)\n   name         wealth `#priors` `#ties`\n   <chr>         <dbl>     <dbl>   <dbl>\n 1 Acciaiuoli       10        53       2\n 2 Albizzi          36        65       3\n 3 Barbadori        55         0      14\n 4 Bischeri         44        12       9\n 5 Castellani       20        22      18\n 6 Ginori           32         0       9\n 7 Guadagni          8        21      14\n 8 Lamberteschi     42         0      14\n 9 Medici          103        53      54\n10 Pazzi            48         0       7\n11 Peruzzi          49        42      32\n12 Pucci             3         0       1\n13 Ridolfi          27        38       4\n14 Salviati         10        35       5\n15 Strozzi         146        74      29\n16 Tornabuoni       48         0       7\n#\n# Edge Data: 20 × 2\n   from    to\n  <int> <int>\n1     1     9\n2     2     6\n3     2     7\n# ℹ 17 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThis new graph class just subclasses `igraph` and simply represents the network in a tidy fashion, printing two data frames, one for nodes and one for edges.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(flo_tidy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_graph\" \"igraph\"   \n```\n\n\n:::\n:::\n\n\n\n\nAny function in R that expects an `igraph` object as input will also accept a `tbl_graph`.\n\nThe function `tbl_graph()` can be used to create a network from scratch with two data frames.\nIt is basically equivalent to `graph_from_data_frame()`. \n\nTo create random graphs with the usual generators, check out the `create_*()` and `play_*()` families of functions.\n\n## Standard verbs\n\nThe tidy framework, specifically thinking about `dplyr`, is about providing verbs which help to\nsolve common data manipulation tasks, such as `mutate()`, `select()`, `filter()`, and\n`summarise()`. The challange for the `tbl_graph` objects is that these verbs somehow need to work with two \ndifferent data frames. The way `tidygraph` solves this is via a pointer to the data frame which is supposed to be manipulated. This pointer can be changed with the verb `activate()`. By default the nodes are activated, which can also be seen with the print function (see line 5 in the output of flo_tidy). To activate the edge data frame, simply use `activate(\"edges\")`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy %>% activate(\"edges\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tbl_graph: 16 nodes and 20 edges\n#\n# An undirected simple graph with 2 components\n#\n# Edge Data: 20 × 2 (active)\n    from    to\n   <int> <int>\n 1     1     9\n 2     2     6\n 3     2     7\n 4     2     9\n 5     3     5\n 6     3     9\n 7     4     7\n 8     4    11\n 9     4    15\n10     5    11\n11     5    15\n12     7     8\n13     7    16\n14     9    13\n15     9    14\n16     9    16\n17    10    14\n18    11    15\n19    13    15\n20    13    16\n#\n# Node Data: 16 × 4\n  name       wealth `#priors` `#ties`\n  <chr>       <dbl>     <dbl>   <dbl>\n1 Acciaiuoli     10        53       2\n2 Albizzi        36        65       3\n3 Barbadori      55         0      14\n# ℹ 13 more rows\n```\n\n\n:::\n:::\n\n\n\nAny data manipulation would now be done on the edge data frame. \n\nHaving \"activated\" a data frame, many of the known dplyr verbs can be used to manipulate the \ndata frame. The activation process might indicate that edges and nodes can only be manipulated separately, which is certainly not desirable. It is, however, possible to gain access to the edge data frame when nodes are activated via the `.E()`. Similarly, nodes can be accessed via `.N()` when edges are activated.\nIn the below example, we activate the edges and create a new edge attribute which indicates if a family\nis connected to the Medici or not.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy <- flo_tidy %>% \n  activate(\"edges\") %>% \n  mutate(to_medici=(.N()$name[from]==\"Medici\" | .N()$name[to]==\"Medici\"))\n```\n:::\n\n\n\n\nThis particular use case is helpful for visualizations. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(flo_tidy, \"stress\") +\n    geom_edge_link0(aes(edge_color = to_medici)) +\n    geom_node_point(shape = 21, size = 10, fill = \"grey66\") +\n    geom_node_text(aes(label = name)) +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](tidygraph-basics_files/figure-html/connect-medici-plot-1.png){width=672}\n:::\n:::\n\n\n\n\nThe `dplyr` verb `filter()` can be used to obtain a subgraph that satisfies given conditions on the nodes.\nNote that in the case that you filter on nodes, also edges will be effected. If a node does not satisfy the\ncondition, then all edges connected to that node disappear. This is not the case for edges though.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy %>%\n    activate(\"edges\") %>%\n    filter(to_medici) %>%\n    ggraph(\"stress\", bbox = 10) +\n    geom_edge_link0(edge_color = \"black\") +\n    geom_node_point(shape = 21, size = 10, fill = \"grey66\") +\n    geom_node_text(aes(label = name)) +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](tidygraph-basics_files/figure-html/filter-example-1.png){width=672}\n:::\n:::\n\n\n\n\n## Joins\n\n## New Verbs\n",
    "supporting": [
      "tidygraph-basics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}