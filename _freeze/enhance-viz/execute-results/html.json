{
  "hash": "fa793131e6d2d67434ae1dea7638332f",
  "result": {
    "engine": "knitr",
    "markdown": "# Enhancing Visualizations\n\n\n\n\n\n\n\n\nEverything that was covered so far should be enough to produce nice network visualizations, especially for scientific publications. However, `ggraph` has a lot more advanced functions/parameter settings to further enhance your visualization.  If you are looking for something specific, it is always a good idea to read the documentation of the geoms. \n\n## use the ggforce\n\nThe `ggforce` package works pretty nicely with `ggraph`. You can, for instance, use\nthe `geom_mark_*()` functions to highlight clusters.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(665)\n\n## create network with a group structure\ng <- sample_islands(9, 40, 0.4, 15)\ng <- igraph::simplify(g)\nV(g)$grp <- as.character(rep(1:9, each = 40))\n\nbb <- layout_as_backbone(g, keep = 0.4)\nE(g)$col <- F\nE(g)$col[bb$backbone] <- T\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, #|\n    layout = \"manual\",\n    x = bb$xy[, 1],\n    y = bb$xy[, 2]\n) +\n    geom_edge_link0(aes(col = col), width = 0.2) +\n    geom_node_point(aes(fill = grp), shape = 21, size = 3) +\n    geom_mark_hull(\n        aes(x, y, group = grp, fill = grp),\n        concavity = 4,\n        expand = unit(2, \"mm\"),\n        alpha = 0.25\n    ) +\n    scale_color_brewer(palette = \"Set1\") +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme_graph() +\n    theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/network-grps-sol-1.png){width=672}\n:::\n:::\n\n\n\n\nOf course you can also add a label to your clusters.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, #|\n    layout = \"manual\",\n    x = bb$xy[, 1],\n    y = bb$xy[, 2]\n) +\n    geom_edge_link0(aes(col = col), width = 0.2) +\n    geom_node_point(aes(fill = grp), shape = 21, size = 3) +\n    geom_mark_hull(\n        aes(x, y, group = grp, fill = grp, label = grp),\n        concavity = 4,\n        expand = unit(2, \"mm\"),\n        alpha = 0.25\n    ) +\n    scale_color_brewer(palette = \"Set1\") +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme_graph() +\n    theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/network-grps-label-sol-1.png){width=672}\n:::\n:::\n\n\n\n\nIf you want to avoid node overlaps, you can use `geom_node_voronoi()`.\nSo this is actually already implemented in `ggraph`, but originates from `geom_voronoi_tile()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g,\n    layout = \"manual\",\n    x = bb$xy[, 1],\n    y = bb$xy[, 2]\n) +\n    geom_edge_link0(aes(filter = !col, col = col), width = 0.2) +\n    geom_node_voronoi(\n        aes(x, y, fill = grp),\n        max.radius = 0.4,\n        expand = unit(-0.5, \"mm\"),\n        colour = \"black\"\n    ) +\n    scale_color_brewer(palette = \"Set1\") +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme(\n        legend.position = \"none\",\n        panel.grid = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text = element_blank()\n    ) +\n    theme_graph() +\n    theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/network-voronoi-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Small tricks for common problems \n\n> \"How can I achieve that my directed edges stop at the node border, independent from the node size?\" \n\nThis one has given me headaches for the longest time. No matter what I tried, I always ended up with\nsomething like the below plot.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## create a random network\nset.seed(1071)\ng <- sample_pa(30, 1)\nV(g)$degree <- degree(g, mode = \"in\")\n\nggraph(g, \"stress\") +\n    geom_edge_link(\n        aes(end_cap = circle(node2.degree + 2, \"pt\")),\n        edge_colour = \"black\",\n        arrow = arrow(\n            angle = 10,\n            length = unit(0.15, \"inches\"),\n            ends = \"last\",\n            type = \"closed\"\n        )\n    ) +\n    geom_node_point(aes(size = degree), col = \"grey66\", show.legend = FALSE) +\n    scale_size(range = c(3, 11)) +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/arrow-size-1.png){width=672}\n:::\n:::\n\n\n\n\nThe overlap can be avoided by using the `I()` function from base R, which\ntreats the entries of a vector \"as is\". So we know that if a node has degree 5, it will be mapped to\na circle with radius (or diameter?) \"5pt\". Since this means, that you have no control over the scaling,\nyou need to do that beforehand.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## this function is borrowed from the ambient package\nnormalise <- function(x, from = range(x), to = c(0, 1)) {\n    x <- (x - from[1]) / (from[2] - from[1])\n    if (!identical(to, c(0, 1))) {\n        x <- x * (to[2] - to[1]) + to[1]\n    }\n    x\n}\n\n## map to the range you want\nV(g)$degree <- normalise(V(g)$degree, to = c(3, 11))\n\nggraph(g, \"stress\") +\n    geom_edge_link(\n        aes(end_cap = circle(node2.degree + 2, \"pt\")),\n        edge_colour = \"grey25\",\n        arrow = arrow(\n            angle = 10,\n            length = unit(0.15, \"inches\"),\n            ends = \"last\",\n            type = \"closed\"\n        )\n    ) +\n    geom_node_point(aes(size = I(degree)), col = \"grey66\") +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/arrows-size-sol-1.png){width=672}\n:::\n:::\n\n\n\n\nI would not be surprised though if there is an even easier fix for this problem.\n\n> \"How can I lower the opacity of nodes without making edges visible underneath?\"\n\nOne of the rules I try to follow is that edges should not be visible on top of nodes.\nUsually that is easy to achieve by drawing the edges before the nodes. But if you \nwant to lower the opacity of nodes, they do become visible again.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- sample_gnp(20, 0.5)\nV(g)$degree <- degree(g)\n\nggraph(g, \"stress\") +\n    geom_edge_link(edge_colour = \"grey66\") +\n    geom_node_point(\n        size = 8,\n        aes(alpha = degree),\n        col = \"red\",\n        show.legend = FALSE\n    ) +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/alpha-nodes-1.png){width=672}\n:::\n:::\n\n\n\n\nThe solution is rather simple. Just add a node layer with the same aesthetics below with\n`alpha=1` (default) and `color=\"white\"` (or the background color of the plot).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, \"stress\") +\n    geom_edge_link(edge_colour = \"grey66\") +\n    geom_node_point(size = 8, col = \"white\") +\n    geom_node_point(\n        aes(alpha = degree),\n        size = 8,\n        col = \"red\",\n        show.legend = FALSE\n    ) +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/alpha-nodes-sol-1.png){width=672}\n:::\n:::\n\n\n\n\nOf course you could also use `start_cap` and `end_cap` here, but you may have to fiddle again as in the last example. \n\n> \"How can I enhance readability of node labels in hairball graphs?\"\n\nSometimes it is really hard to make labels readable when the network is very cluttered\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- sample_gnp(50, 0.7)\nV(g)$name <- sapply(1:50, function(x) paste0(sample(LETTERS, 4), collapse = \"\"))\nE(g)$weight <- runif(ecount(g))\n\nggraph(g) +\n    geom_edge_link0(aes(edge_color = weight, edge_linewidth = weight), show.legend = FALSE) +\n    geom_node_point(size = 8, color = \"#44a6c6\") +\n    geom_node_text(aes(label = name), fontface = \"bold\") +\n    scale_edge_color_continuous(low = \"grey66\", high = \"black\") +\n    scale_edge_width(range = c(0.1, 0.5)) +\n    theme_graph() +\n    coord_fixed()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing \"stress\" as default layout\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/unreadable-labels-1.png){width=768}\n:::\n:::\n\n\n\n\nHere you can make use of the fact that the layout of the nodes are stored in a \"hidden\" data frame when a `ggraph` object is constructed. That means you can use other geoms from other packages. In this case, the `shadowtext` package as shown below.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, \"stress\") +\n    geom_edge_link0(aes(edge_color = weight, edge_linewidth = weight), show.legend = FALSE) +\n    geom_node_point(size = 8, color = \"#44a6c6\") +\n    shadowtext::geom_shadowtext(aes(x, y, label = name), color = \"black\", size = 4, bg.colour = \"white\") +\n    scale_edge_color_continuous(low = \"grey66\", high = \"black\") +\n    scale_edge_width(range = c(0.1, 0.5)) +\n    theme_graph() +\n    coord_fixed()\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/shadowtext-labels-1.png){width=768}\n:::\n:::\n\n\n\n\n## Edge bundling\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr <- edgebundle::us_flights\nstates <- map_data(\"state\")\n\nggraph(gr, x = longitude, y = latitude) +\n    geom_polygon(aes(long, lat, group = group), states, color = \"white\", linewidth = 0.2) +\n    coord_sf(crs = \"NAD83\", default_crs = sf::st_crs(4326)) +\n    geom_edge_bundle_force(color = \"white\", width = 0.05)\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/fig-force-bundle-1.png){#fig-force-bundle width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(gr, x = longitude, y = latitude) +\n    geom_polygon(aes(long, lat, group = group), states, color = \"white\", linewidth = 0.2) +\n    coord_sf(crs = \"NAD83\", default_crs = sf::st_crs(4326)) +\n    geom_edge_bundle_path(color = \"white\", width = 0.05)\n```\n\n::: {.cell-output-display}\n![](enhance-viz_files/figure-html/fig-path-bundle-1.png){#fig-path-bundle width=672}\n:::\n:::\n\n\n\n\n## snahelper\n\nEven with a lot of experience, it may still be a painful process to produce nice looking\nfigures by writing `ggraph` code. Enter the `snahelper`. \n\n```r\ninstall.packages(\"snahelper\")\n```\n\nThe `snahelper` is an RStudio addin which provides\nyou with a GUI to plot networks. Instead of writing code, you simply use drop-down menus to assign \nattributes to aesthetics or change appearances globally. One great feature of the addin is that you \ncan adjust the position of nodes individually if you are not satisfied with their location.\nOnce you are done, you can either directly export the figure to png or automatically insert the code to produce the figure into your script. That way, you can review the code and hopefully learn something from it. Below if a demo that shows its functionality.\n\n![](https://raw.githubusercontent.com/schochastics/snahelper/master/man/figures/snahelper.gif)\n\n\nTo use the addin, simply highlight the variable name of your network within an R script and\nchoose the SNAhelper from the Addins drop-down menu within RStudio. You can find more about the \nAddin on its dedicated [pkgdown page](http://snahelper.schochastics.net)\n\n\n## Misc\n\nSome things that I frequently use are the following:\n\n- change the `end_cap` in `geom_edge_link()` to end edges before reaching the node. This is helpful\n  for directed edges to not make the arrows disappear.\n- `legend.position` in `theme()` controls all legends at once. If you don't want to show a specific legend, \n use `guide = \"none\"` in the respective `scale_*` function.\n- use `scale_color_viridis_c()` and `scale_color_viridis_d()`. The viridis colour palette makes plots easier to read by those with colorblindness and print well in grey scale.\n",
    "supporting": [
      "enhance-viz_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}