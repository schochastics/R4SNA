{
  "hash": "22fee4cbf6da786fd625c6e3fbabfe01",
  "result": {
    "engine": "knitr",
    "markdown": "# Signed Networks {#sec-signed-networks}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(signnet)\nlibrary(networkdata)\n```\n:::\n\n\n\n\n## Introduction\n\nTraditional SNA usually deals with relations among entities (e.g. people) that are positive, including \"friendship\", \"advice seeking\", etc. Most network analytic tools are devised under this premise, be that centrality indices, clustering tools and so forth.\nBut of course not all occurring relations are positive. People can be friends but also foes. \n\nThis gives rise to signed networks. These networks are usually composed of both, positive and negative, ties\nmeasured among a set of entities. Traditional network analytic tools are not applicable to such networks without\nadapting for negative ties.\n\nThe `signnet` package brings together methods that have been developed to analyse signed networks. This includes\n\n* Structural balance\n* Blockmodeling\n* Centrality\n* Signed two-mode networks\n\n## Data structures for signed networks\n\nThe foundation of `signnet` is provided by `igraph`. All functions in the package assume\nthat an igraph object is a signed network if it has an edge attribute \"sign\" with values 1 (positive) or -1 (negative).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- graph.full(5, directed = FALSE, loops = FALSE)\nE(g)$sign <- 1\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH c6c7c73 U--- 5 10 -- Full graph\n+ attr: name (g/c), loops (g/l), sign (e/n)\n+ edges from c6c7c73:\n [1] 1--2 1--3 1--4 1--5 2--3 2--4 2--5 3--4 3--5 4--5\n```\n\n\n:::\n:::\n\n\nAll methods throw an error if the sign attribute is missing or contains other values than -1 and 1.\n\nMatrices associated with a signed network follow the `igraph` naming scheme.\nThe signed adjacency matrix can be obtained with `as_adj_signed()`.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"tribes\")\nas_adj_signed(tribes)[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Gavev Kotun Ove Alika Nagam\nGavev     0     1  -1    -1    -1\nKotun     1     0  -1     0    -1\nOve      -1    -1   0     1     0\nAlika    -1     0   1     0     0\nNagam    -1    -1   0     0     0\n```\n\n\n:::\n:::\n\n\nThe signed Laplacian matrix is obtained by `laplacian_matrix_signed()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaplacian_matrix_signed(tribes)[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Gavev Kotun Ove Alika Nagam\nGavev     8    -1   1     1     1\nKotun    -1     8   1     0     1\nOve       1     1   6    -1     0\nAlika     1     0  -1     3     0\nNagam     1     1   0     0     7\n```\n\n\n:::\n:::\n\n\nThe `signnet` package includes two well known example datasets. \n\nThe \"tribes\" dataset is a signed social network of tribes of the Gahuku–Gama alliance structure of the Eastern Central Highlands of New Guinea. The network contains sixteen tribes connected by friendship (\"rova\") and enmity (\"hina\").\n\nThe \"cowList\" dataset contains a list of 52 signed networks of inter-state relations over time (1946-1999). \nTwo countries are connected by a positive tie if they form an alliance or have a peace treaty. A negative tie\nexists between countries who are at war or in other kinds of conflicts. The dataset is derrived from the \n[correlates of war](https://correlatesofwar.org/).\n\n## Structural Balance \n\nThe principles underlying structural balance are based on a theory in social psychology dating back to the work of Heider in the 1940s, which was generalized and extended to graphs by Cartwright and Harary in the 1950s. In its simplest form, it is defined via triangles. \nA triangle is balanced if all ties are positive (“the friend of a friend is a friend”) or only one tie is positive (“the enemy of my enemy is my friend”). The remaining configurations are said to be unbalanced.\n\n![](assets/img/balance_triples.png)\n\nA network is balanced if i.a., it can be partitioned into two vertex subsets, such that intra-group edges are all positive and inter-group edges are all negative. \n\nA (random) balanced network can be obtained with the function `sample_islands_signed()` which is pretty much the\nsame as `sample_islands()` from the `igraph` package. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- sample_islands_signed(islands.n = 2,islands.size = 10,\n                           islands.pin = 0.8,n.inter = 5)\n```\n:::\n\n(The function `ggsigned()` can be used to visualize signed networks. Note that this requires the package `ggraph` to be installed.)\nIncreasing `islands.n` leads to \"clusterable\" networks as defined by Davis.\n\nA balanced network only contains balanced triangles. This can be verified with `count_signed_triangles()`.\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_signed_triangles(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+++ ++- +-- --- \n129   0   6   0 \n```\n\n\n:::\n:::\n\nNote the absence of `++-` and `---` triangles.\n\nTo list all triangles use `signed_triangles()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(signed_triangles(g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     V1 V2 V3 P\n[1,]  8  1  2 3\n[2,]  8  1  4 3\n[3,]  8  1  7 3\n[4,]  8  1  6 3\n[5,]  8  2  6 3\n[6,]  8  2  4 3\n```\n\n\n:::\n:::\n\nThe column P indicated the number of positive ties in the triangle. A value of 3 indicates that the triangle is \"+++\".\n\n\n\n## Balancedness\nDetermining if a network is balanced or not is easy, but measuring a degree of balancedness (i.e. how close is a network to be balanced?) is not. The package, so far, implements three methods to calculate balance scores. All are defined such that a value of one indicates perfect balance and zero perfect unbalance. Though for intermediate networks, results may vary significantly. Check the paper by Samin Aref (and his other work) for more details.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbalance_score(g, method = \"triangles\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nbalance_score(g, method = \"walk\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nbalance_score(g, method = \"frustration\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\"triangles\" returns the fraction of balanced triangles.  \n\n\"walk\" is based on eigenvalues of the signed and underlying unsigned network. Check the paper by Estrada for details.  \n\n\"frustration\" assumes that the network can be partitioned into two groups, where intra group edges are positive and inter group edges are negative. The index is defined as the sum of intra group negative and inter group positive edges. Note that the problem is NP complete and only an upper bound is returned (based on simulated annealing). The function `frustration_exact()` implements an integer program to solve the exact optimization problem. More details can be found in the work of Aref.\n\nThere disagreement for non-balanced networks can be seen with the included \"tribes\" dataset.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"tribes\")\nbalance_score(tribes, method = \"triangles\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.867647\n```\n\n\n:::\n\n```{.r .cell-code}\nbalance_score(tribes, method = \"walk\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.357576\n```\n\n\n:::\n\n```{.r .cell-code}\nbalance_score(tribes, method = \"frustration\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.758621\n```\n\n\n:::\n:::\n\n\n## Triangles\n\nThe function  `triad_census_signed()` calculates the\nsigned triad census of a directed signed network. While the unsigned triad census has only 16 possible outcomes, there are 138 non-isomorphic signed triads, shown below.\n\n![](assets/img/signed_triads.png)\n\nThe naming scheme is \"xxx-yyyyyy\" where \"xxx\" corresponds to the name of the respective unsigned triad and \"yyyyyy\" is \na string of \"0\", \"N\", \"P\", describing the type of ties present. So \"300-NNNNNN\" is a triad with all ties present and all ties are negative. \n\n\n## Traditional Blockmodeling \n\nIn signed blockmodeling, the goal is to determine `k` blocks of nodes such that all intra-block edges\nare positive and inter-block edges are negative. In the example below, we construct a network with a perfect \nblock structure with `sample_islands_signed()`. The network consists of 10 blocks with 10 vertices each, where each block \nhas a density of 1 (of positive edges). The function `signed_blockmodel()` is used to construct the blockmodel.\nThe parameter `k` is the number of desired blocks. `alpha` is a trade-off parameter. The function minimizes $P(C)=\\alpha N+(1-\\alpha)P$, where $N$ is the total number of negative ties within blocks and $P$ be the total number of positive ties between blocks. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- sample_islands_signed(10,10,1,20)\nclu <- signed_blockmodel(g,k = 10,alpha = 0.5)\ntable(clu$membership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 1  2  3  4  5  6  7  8  9 10 \n10 10 10 10 10 10 10 10 10 10 \n```\n\n\n:::\n\n```{.r .cell-code}\nclu$criterion\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nThe function returns a list with two entries. The block membership of nodes and the value of $P(C)$.\n\nThe function `ggblock()` can be used to plot the outcome of the blockmodel (`ggplot2` is required).\n\n::: {.cell}\n\n```{.r .cell-code}\nggblock(g,clu$membership,show_blocks = TRUE)\n```\n\n::: {.cell-output-display}\n![](signed-networks_files/figure-html/blockmodel-ex-plot-1.png){width=672}\n:::\n:::\n\n\nIf the parameter `annealing` is set to TRUE, simulated annealing is used in the optimization step. \nThis generally leads to better results but longer runtimes.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"tribes\")\nset.seed(44) #for reproducibility\n\nsigned_blockmodel(tribes,k = 3,alpha=0.5,annealing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$membership\n [1] 1 1 2 2 3 2 2 2 3 3 2 2 3 3 1 1\n\n$criterion\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nsigned_blockmodel(tribes,k = 3,alpha=0.5,annealing = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$membership\n [1] 1 1 2 2 3 2 2 2 3 3 2 2 3 3 1 1\n\n$criterion\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n## Generalized Blockmodeling\n\nThe function `signed_blockmodel()` is only able to provide a blockmodel where the diagonal blocks are positive and \noff-diagonal blocks are negative. The function `signed_blockmodel_general()` can be used to specify different block structures.\nIn the below example, we construct a network that contains three blocks. Two have positive and one has negative intra-group ties.\nThe inter-group edges are negative between group one and two, and one and three. Between group two and three, all edges are positive.\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 <- g2 <- g3 <- graph.full(5)\n\nV(g1)$name <- as.character(1:5)\nV(g2)$name <- as.character(6:10)\nV(g3)$name <- as.character(11:15)\n\ng <- Reduce(\"%u%\",list(g1,g2,g3))\nE(g)$sign <- 1\nE(g)$sign[1:10] <- -1\ng <- add.edges(g,c(rbind(1:5,6:10)),attr = list(sign=-1))\ng <- add.edges(g,c(rbind(1:5,11:15)),attr = list(sign=-1))\ng <- add.edges(g,c(rbind(11:15,6:10)),attr = list(sign=1))\n```\n:::\n\n\nThe parameter `blockmat` is used to specify the desired block structure.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(424)\nblockmat <- matrix(c(1,-1,-1,-1,1,1,-1,1,-1),3,3,byrow = TRUE)\nblockmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1   -1   -1\n[2,]   -1    1    1\n[3,]   -1    1   -1\n```\n\n\n:::\n\n```{.r .cell-code}\ngeneral <- signed_blockmodel_general(g,blockmat,alpha = 0.5)\ntraditional <- signed_blockmodel(g,k = 3,alpha = 0.5,annealing = TRUE)\n\nc(general$criterion,traditional$criterion)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 6\n```\n\n\n:::\n:::\n\n\n![](assets/img/blockmodel_general.png)\n\n## Centrality\n\nThere exist dozens of indices for networks with positive ties, but for signed networks they are rather scarce.\nThe package implements three indices so far. Versions of degree and eigenvector centrality, and PN centrality by Everett & Borgatti.\n\nDegree centrality can be calculated in four different ways with `degree_signed()`, specified by the `type` parameter:\n\n* `type=\"pos\"` count only positive neighbors\n* `type=\"neg\"` count only negative neighbors\n* `type=\"ratio\"` positive neighbors/(positive neighbors+negative neighbors)\n* `type=\"net\"` positive neighbors-negative neighbors\n\nThe `mode` parameter can be used to get \"in\" and \"out\" versions for directed networks.\n\nThe PN index is very similar to Katz status and Hubbell's measure for networks with only positive ties.\nThe technical details can be found in the paper by Everett & Borgatti.\n\nThe below example illustrates all indices with a network where signed degree can not distinguish vertices.\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(0,  1,  0,  1,  0,  0,  0, -1, -1,  0,  \n               1,  0,  1, -1,  1, -1, -1,  0,  0,  0,  \n               0,  1,  0,  1, -1,  0,  0,  0, -1,  0,  \n               1, -1,  1,  0,  1, -1, -1,  0,  0,  0,  \n               0,  1, -1,  1,  0,  1,  0, -1,  0, -1,  \n               0, -1,  0, -1,  1,  0,  1,  0,  1, -1,  \n               0, -1,  0, -1,  0,  1,  0,  1, -1,  1,  \n              -1,  0,  0,  0, -1,  0,  1,  0,  1,  0,  \n              -1,  0, -1,  0,  0,  1, -1,  1,  0,  1,  \n               0,  0,  0,  0, -1, -1,  1,  0,  1,  0),10,10)\n\ng <- graph_from_adjacency_matrix(A,\"undirected\",weighted = \"sign\")\n\ndegree_signed(g,type=\"ratio\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n```\n\n\n:::\n\n```{.r .cell-code}\neigen_centrality_signed(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.6221496 1.0000000 0.7451885 1.0000000 0.8999004 0.6428959 0.3582816\n [8] 0.3747192 0.2808741 0.0783457\n```\n\n\n:::\n\n```{.r .cell-code}\npn_index(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.900975 0.861348 0.907700 0.861348 0.841066 0.849656 0.861732 0.901591\n [9] 0.850985 0.907293\n```\n\n\n:::\n:::\n\n\nNote that PN centrality and eigenvector centrality differ significantly for this network.\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(eigen_centrality_signed(g),pn_index(g),method = \"kendall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.244444\n```\n\n\n:::\n:::\n\n\n### A note on eigenvector centrality\n\nThe adjacency matrix of a signed network may not have a dominant eigenvalue. This means it is not clear which eigenvector should be used. In addition it is possible for the adjacency matrix to have repeated eigenvalues and hence multiple linearly independent eigenvectors. In this case certain centralities can be arbitrarily assigned. The `eigen_centrality_signed()` function returns an error if this is the case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c( 0,  1,  1, -1,  0,  0, -1,  0,  0, \n               1,  0,  1,  0, -1,  0,  0, -1,  0, \n               1,  1,  0,  0,  0, -1,  0,  0, -1, \n              -1,  0,  0,  0,  1,  1, -1,  0,  0, \n               0, -1,  0,  1,  0,  1,  0, -1,  0, \n               0,  0, -1,  1,  1,  0,  0,  0, -1, \n              -1,  0,  0, -1,  0,  0,  0,  1,  1, \n               0, -1,  0,  0, -1,  0,  1,  0,  1, \n               0,  0, -1,  0,  0, -1,  1,  1, 0), 9, 9)\n\ng <- igraph::graph_from_adjacency_matrix(A,\"undirected\",weighted = \"sign\")\neigen_centrality_signed(g)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eigen_centrality_signed(g): no dominant eigenvalue exists\n```\n\n\n:::\n:::\n\n\n\n## Scientific Reading\n\nEverett, Martin G., and Stephen P. Borgatti. 2014. \"Networks Containing Negative Ties.\" Social Networks 38: 111–20. \n\nBonacich, Phillip, and Paulette Lloyd. 2004. \"Calculating Status with Negative Relations.\" Social Networks 26 (4): 331–38. \n\nDoreian, Patrick, and Andrej Mrvar. 1996. \"A Partitioning Approach to Structural Balance.\" Social Networks 18 (2): 149–68. \n\nDoreian, Patrick, and Andrej Mrvar. 2009. \"Partitioning Signed Social Networks.\" Social Networks 31 (1): 1–11. \n\nDoreian, Patrick, and Andrej Mrvar. 2015. \"Structural Balance and Signed International Relations.\" Journal of Social Structure 16: 1.\n\nHeider, Fritz. 1946. \"Attitudes and Cognitive Organization.\" The Journal of Psychology 21 (1): 107–12. \n\nCartwright, Dorwin, and Frank Harary. 1956. \"Structural Balance: A Generalization of Heider’s Theory.\" Psychological Review 63 (5): 277.\n\nDavis, James A. 1967. \"Clustering and Structural Balance in Graphs.\" Human Relations 20 (2): 181–87. \n\nAref, Samin, and Mark C. Wilson. 2018. \"Measuring Partial Balance in Signed Networks.\" Journal of Complex Networks 6 (4): 566–95. \n\nEstrada, Ernesto. 2019. \"Rethinking Structural Balance in Signed Social Networks.\" Discrete Applied Mathematics\n",
    "supporting": [
      "signed-networks_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}