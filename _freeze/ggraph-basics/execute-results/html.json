{
  "hash": "41ee42595db0128fa94b41ef59f0ba5d",
  "result": {
    "engine": "knitr",
    "markdown": "# Grammar of Graphs\n\n\n\n\n\n\n## Quick plots\n\nIt is always a good idea to take a quick look at your network before starting any analysis. \nThis can be done with the function `autograph()` from the `ggraph` package.\n\n::: {.cell}\n\n```{.r .cell-code}\nautograph(gotS1)\n```\n\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/quickplot-1.png){width=672}\n:::\n:::\n\n\n`autograph()` allows you to specify node/edge colours too but it really is only meant to \ngive you a quick overview without writing a massive amount of code. Think of it as the\n`plot()` function for `ggraph`\n\nBefore we continue, we add some more node attributes to the GoT network that can be used during visualization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## define a custom color palette\ngot_palette <- c(\n    \"#1A5878\", \"#C44237\", \"#AD8941\", \"#E99093\",\n    \"#50594B\", \"#8968CD\", \"#9ACD32\"\n)\n\n## compute a clustering for node colors\nV(gotS1)$clu <- as.character(membership(cluster_louvain(gotS1)))\n\n## compute degree as node size\nV(gotS1)$size <- degree(gotS1)\n```\n:::\n\n\n\nOnce you want to move beyond quick plots, you need to understand the basics of, or at least develop a feeling for, \nthe grammar of graphics to work with `ggraph`.\n\nInstead of explaining the grammar, let us directly jump into some code and work through it one line at a time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size >= 26, label = name), family = \"serif\") +\n  scale_fill_manual(values = got_palette) +\n  scale_edge_width(range = c(0.2, 3)) +\n  scale_size(range = c(1, 6)) +\n  theme_graph() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/got-plot-1.png){width=960}\n:::\n:::\n\n\n`ggraph` works with layers. Each layer adds a new feature to the plot and thus builds the figure\nstep-by-step. We will work through each of the layers separately in the following sections.  \n\n## Layout\n\n```r\nggraph(gotS1, layout = \"stress\")\n```\n\nThe first step is to compute a layout. The layout parameter specifies the algorithm to use. \nThe \"stress\" layout is part of the `graphlayouts` package and is always a safe choice \nsince it is deterministic and produces nice layouts for almost any graph.\nI would recommend to use it as your default choice. Other algorithms for, e.g., concentric layouts and clustered networks\nare described further down in this tutorial. For the sake of completeness, here is a list of layout algorithms of \n`igraph`.\n\n```r\nc(\n  \"layout_with_dh\", \"layout_with_drl\", \"layout_with_fr\",\n  \"layout_with_gem\", \"layout_with_graphopt\", \"layout_with_kk\",\n  \"layout_with_lgl\", \"layout_with_mds\", \"layout_with_sugiyama\",\n  \"layout_as_bipartite\", \"layout_as_star\", \"layout_as_tree\"\n)\n```\n\nTo use them, you just need the last part of the name.\n```r\nggraph(gotS1, layout = \"dh\") +\n  ...\n```\n\nNote that there technically is no right or wrong choice. All layout algorithms are in a sense arbitrary since \nwe can choose x and y coordinates freely (compare this to ordinary data!). It is all mostly about aesthetics.\n\nYou can also precompute the layout with the `create_layout()` function. This makes sense in cases where the calculation\nof the layout takes very long and you want to play around with other visual aspects. \n```r\ngotS1_layout <- create_layout(gotS1 = \"stress\")\n\nggraph(gotS1_layout) +\n  ...\n```\n\n## Edges\n\n```r\ngeom_edge_link0(aes(width = weight), edge_colour = \"grey66\")\n```\n\nThe second layer specifies how to draw the edges. Edges can be drawn in many different ways as the list below shows.\n```r\nc(\n  \"geom_edge_arc\", \"geom_edge_arc0\", \"geom_edge_arc2\", \"geom_edge_density\",\n  \"geom_edge_diagonal\", \"geom_edge_diagonal0\", \"geom_edge_diagonal2\",\n  \"geom_edge_elbow\", \"geom_edge_elbow0\", \"geom_edge_elbow2\", \"geom_edge_fan\",\n  \"geom_edge_fan0\", \"geom_edge_fan2\", \"geom_edge_hive\", \"geom_edge_hive0\",\n  \"geom_edge_hive2\", \"geom_edge_link\", \"geom_edge_link0\", \"geom_edge_link2\",\n  \"geom_edge_loop\", \"geom_edge_loop0\"\n)\n```\nYou can do a lot of fancy things with these `geoms` but for a standard network plot,\nyou should always stick with `geom_edge_link0` since it simply draws a straight line between the endpoints. Some tools draw curved edges by default. While this may add some artistic value, it reduces readability. Always go with straight lines! If your network has multiple edges between two nodes, then you can switch to `geom_edge_parallel()`.\n\nIn case you are wondering what the \"0\" stands for: The standard `geom_edge_link()` draws 100 dots on each edge compared to only two dots (the endpoints) in `geom_edge_link0()`.\nThis is done to allow, e.g., gradients along the edge. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/got-plot-grad-1.png){width=960}\n:::\n:::\n\n\nYou can reproduce this figure by substituting  \n```r\ngeom_edge_link(aes(edge_alpha = after_stat(index)), edge_colour = \"black\")\n```\nin the code above. \n\nThe drawback of using `geom_edge_link()` is that the time to render the plot increases and so \ndoes the size of the file if you export the plot ([example](https://twitter.com/schochastics/status/1091355396265201664))\nTypically, you do not need gradients along an edge. Hence, `geom_edge_link0()` should be your default choice\nto draw edges.\n\nWithin `geom_edge_link0`, you can specify the appearance of the edge, either by mapping edge attributes to aesthetics\nor setting them globally for the graph. Mapping attributes to aesthetics is done within `aes()`.\nIn the example, we map the edge width to the edge attribute \"weight\". `ggraph` then automatically scales the\nedge width according to the attribute. The colour of all edges is globally set to \"grey66\".\n\nThe following aesthetics can be used within `geom_edge_link0` either within `aes()` or globally:\n\n- edge_colour (colour of the edge)\n- edge_linewidth  (width of the edge)\n- edge_linetype (linetype of the edge, defaults to \"solid\")\n- edge_alpha (opacity; a value between 0 and 1)\n\n`ggraph` does not automatically draw arrows if your graph is directed. You need to do this manually using \nthe arrow parameter.\n```r\ngeom_edge_link0(aes(...), ...,\n  arrow = arrow(\n    angle = 30, length = unit(0.15, \"inches\"),\n    ends = \"last\", type = \"closed\"\n  )\n)\n```\n\nThe default arrowhead type is \"open\", yet \"closed\" usually has a nicer appearance.\n\n## Nodes\n\n```r\ngeom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size >= 26, label = name), family = \"serif\")\n```\n\nOn top of the edge layer, we draw the node layer. Always draw the node layer above \nthe edge layer. Otherwise, edges will be visible on top of nodes.\nThere are slightly less geoms available for nodes.\n\n```r\nc(\n  \"geom_node_arc_bar\", \"geom_node_circle\", \"geom_node_label\",\n  \"geom_node_point\", \"geom_node_text\", \"geom_node_tile\", \"geom_node_treemap\"\n)\n```\n\nThe most important ones here are `geom_node_point()` to draw nodes as simple geometric objects (circles, squares,...)\nand `geom_node_text()` to add node labels. You can also use `geom_node_label()`, but this draws labels within a box.\n\nThe mapping of node attributes to aesthetics is similar to edge attributes. In the example code, we map the fill attribute of the node shape to the \"clu\" attribute, which holds the result of a clustering, and the size of the nodes to the attribute \"size\". The shape of the node is globally set to 21.\n\nThe figure below shows all possible shapes that can be used for the nodes.\n\n![](assets/img/points-symbols.png)\n\nPersonally, I prefer \"21\" since it draws a border around the nodes. If you prefer another\nshape, say \"19\", you have to be aware of several things. To change the color of shapes 1-20,\nyou need to use the colour parameter. For shapes 21-25 you need to use fill. The colour parameter \nonly controls the border for these cases. \n\nThe following aesthetics can be used within `geom_node_point()` either within `aes()` or globally:\n\n- alpha  (opacity; a value between 0 and 1)\n- colour (colour of shapes 0-20 and border colour for 21-25)\n- fill  (fill colour for shape 21-25)\n- shape (node shape; a value between 0 and 25)\n- size (size of node)\n- stroke (size of node border)\n\nFor `geom_node_text()`, there are a lot more options available, but the most important once are:\n\n- label (attribute to be displayed as node label)\n- colour (text colour)\n- family (font to be used)\n- size (font size)\n\nNote that we also used a filter within `aes()` of `geom_node_text()`. The filter \nparameter allows you to specify a rule for when to apply the aesthetic mappings.\nThe most frequent use case is for node labels (but can also be used for edges or nodes).\nIn the example, we only display the node label if the size attribute is larger than 26.\n\n## Scales\n\n```r\nscale_fill_manual(values = got_palette) +\n  scale_edge_width_continuous(range = c(0.2, 3)) +\n  scale_size_continuous(range = c(1, 6))\n```\n\nThe `scale_*` functions are used to control aesthetics that are mapped within `aes()`.\nYou do not necessarily need to set them, since `ggraph` can take care of it automatically.\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size >= 26, label = name), family = \"serif\") +\n  theme_graph() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `trans` argument of `continuous_scale()` is deprecated as of ggplot2 3.5.0.\nâ„¹ Please use the `transform` argument instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/no-scales-1.png){width=960}\n:::\n:::\n\n\nWhile the node fill and size seem reasonable, the edges are a little too thick.\nIn general, it is always a good idea to add a `scale_*` for each aesthetic within `aes()`.\n\nWhat kind of `scale_*` function you need depends on the aesthetic and on the type of attribute you are mapping.\nGenerally, scale functions are structured like this:  \n`scale_<aes>_<variable type>()`.  \n\nThe \"aes\" part is easy. Just us the type you specified within `aes()`. For edges, however, you have to prepend `edge_`.\nThe \"variable type\" part depends on which scale the attribute is on. Before we continue, it may be \na good idea to briefly discuss what aesthetics make sense for which variable type. \n\n| aesthetic | variable type | notes |\n|--------|----------|--------------|\n| node size | continuous | |\n| edge width| continuous| |\n| node colour/fill | categorical/continuous | use a gradient for continuous variables|\n| edge colour | continuous | categorical only if there are different types of edges |\n| node shape | categorical| only if there are a few categories (1-5). Colour should be the preferred choice|\n| edge linetype| categorical | only if there are a few categories (1-5). Colour should be the preferred choice|\n| node/edge alpha| continuous | |\n\nThe easiest to use scales are those for continuous variables mapped to edge width and node size (also the alpha value, which is not used here). While there are several parameters within `scale_edge_width_continuous()` and `scale_size_continuous()`, the\nmost important one is \"range\" which fixes the minimum and maximum width/size. It usually suffices to\nadjust this parameter.\n\nFor continuous variables that are mapped to node/edge colour, you can use `scale_colour_gradient()`\n`scale_colour_gradient2()` or `scale_colour_gradientn()` (add edge_ before colour for edge colours).\nThe difference between these functions is in how the gradient is constructed. `gradient` creates a two\ncolour gradient (low-high). Simply specify the the two colours to be used (e.g. low = \"blue\", high = \"red\").\n`gradient2` creates a diverging colour gradient (low-mid-high) (e.g. low = \"blue\", mid = \"white\", high = \"red\") \nand `gradientn` a gradient consisting of more than three colours (specified with the colours parameter).\n\nFor categorical variables that are mapped to node colours (or fill in our example), you can\nuse `scale_fill_manual()`. This forces you to choose a color for each category yourself. \nSimply create a vector of colors (see the got_palette) and pass it to the function with the parameter values.\n\n`ggraph` then assigns the colors in the order of the unique values of the categorical variable. This \nare either the factor levels (if the variable is a factor) or the result of sorting the unique values (if the variable is a character).\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(unique(V(gotS1)$clu))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\"\n```\n\n\n:::\n:::\n\nIf you want more control over which value is mapped to which colour, you can pass the vector of colours\nas a named vector.\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_palette2 <- c(\n    \"5\" = \"#1A5878\", \"3\" = \"#C44237\", \"2\" = \"#AD8941\",\n    \"1\" = \"#E99093\", \"4\" = \"#50594B\", \"7\" = \"#8968CD\", \"6\" = \"#9ACD32\"\n)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/got-plot-pal2-1.png){width=1248}\n:::\n:::\n\n\nUsing your own colour palette gives your network a unique touch. If you can't be bothered with \nchoosing colours, you may want to consider `scale_fill_brewer()` and `scale_colour_brewer()`.\nThe function offers all palettes available at [colorbrewer2.org](http://colorbrewer2.org/). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size >= 26, label = name), family = \"serif\") +\n  scale_fill_brewer(palette = \"Dark2\") +\n  scale_edge_width_continuous(range = c(0.2, 3)) +\n  scale_size_continuous(range = c(1, 6)) +\n  theme_graph() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/got-plot-brewer-1.png){width=960}\n:::\n:::\n\n\n(*Check out this [github repo](https://github.com/EmilHvitfeldt/r-color-palettes) from Emil Hvitfeldt for a comprehensive list of color palettes available in R*)\n\n## Themes\n\n```r\ntheme_graph() +\n  theme(legend.position = \"none\")\n```\n\nthemes control the overall look of the plot. There are a lot of options within the `theme()`\nfunction of `ggplot2`. Luckily, we really don't need any of those. `theme_graph()` is used\nto erase all of the default ggplot theme (e.g. axis, background, grids, etc.) since they are irrelevant for networks. \nThe only option worthwhile in `theme()` is `legend.position`, which we set to \"none\", i.e. don't show the legend.\n\nThe code below gives an example for a plot with a legend.\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size >= 26, label = name), family = \"serif\") +\n  scale_fill_manual(values = got_palette) +\n  scale_edge_width_continuous(range = c(0.2, 3)) +\n  scale_size_continuous(range = c(1, 6)) +\n  theme_graph() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](ggraph-basics_files/figure-html/got-plot-legend-1.png){width=960}\n:::\n:::\n",
    "supporting": [
      "ggraph-basics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}