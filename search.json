[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R4SNA - R for Social Network Analysis",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "visualization-intro.html",
    "href": "visualization-intro.html",
    "title": "7  Introduction",
    "section": "",
    "text": "7.1 Required libraries\nTo run all the code in this tutorial, you need to install and load several packages.\ninstall.packages(c(\"igraph\", \"graphlayouts\", \"ggraph\", \"ggforce\"))\ndevtools::install_github(\"schochastics/networkdata\")\nMake sure you have at least the version given below. Some of the examples may not be backward compatible.\npackageVersion(\"igraph\")\n\n[1] '1.6.0'\n\npackageVersion(\"graphlayouts\")\n\n[1] '1.0.2'\n\npackageVersion(\"ggraph\")\n\n[1] '2.1.0.9000'\n\npackageVersion(\"networkdata\")\n\n[1] '0.1.15'\n\npackageVersion(\"ggforce\")\n\n[1] '0.4.1'\nigraph is mostly used for its data structures and graphlayouts and ggraph for visualizations. The networkdata package contains a huge amount of example network data that always comes in handy for learning new visualization techniques.\nlibrary(igraph)\nlibrary(ggraph)\n\nLoading required package: ggplot2\n\nlibrary(graphlayouts)\nlibrary(ggforce)",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "ggraph-basics.html",
    "href": "ggraph-basics.html",
    "title": "8  Grammar of Graphs",
    "section": "",
    "text": "8.1 Quick plots\nIt is always a good idea to take a quick look at your network before starting any analysis. This can be done with the function autograph() from the ggraph package.\nautograph(gotS1)\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\nautograph() allows you to specify node/edge colours too but it really is only meant to give you a quick overview without writing a massive amount of code. Think of it as the plot() function for ggraph\nBefore we continue, we add some more node attributes to the GoT network that can be used during visualization.\n## define a custom color palette\ngot_palette &lt;- c(\n    \"#1A5878\", \"#C44237\", \"#AD8941\", \"#E99093\",\n    \"#50594B\", \"#8968CD\", \"#9ACD32\"\n)\n\n## compute a clustering for node colors\nV(gotS1)$clu &lt;- as.character(membership(cluster_louvain(gotS1)))\n\n## compute degree as node size\nV(gotS1)$size &lt;- degree(gotS1)\nOnce you want to move beyond quick plots, you need to understand the basics of, or at least develop a feeling for, the grammar of graphics to work with ggraph.\nInstead of explaining the grammar, let us directly jump into some code and work through it one line at a time.\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size &gt;= 26, label = name), family = \"serif\") +\n  scale_fill_manual(values = got_palette) +\n  scale_edge_width(range = c(0.2, 3)) +\n  scale_size(range = c(1, 6)) +\n  theme_graph() +\n  theme(legend.position = \"none\")\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\nggraph works with layers. Each layer adds a new feature to the plot and thus builds the figure step-by-step. We will work through each of the layers separately in the following sections.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grammar of Graphs</span>"
    ]
  },
  {
    "objectID": "ggraph-basics.html#layout",
    "href": "ggraph-basics.html#layout",
    "title": "8  Grammar of Graphs",
    "section": "8.2 Layout",
    "text": "8.2 Layout\nggraph(gotS1, layout = \"stress\")\nThe first step is to compute a layout. The layout parameter specifies the algorithm to use. The “stress” layout is part of the graphlayouts package and is always a safe choice since it is deterministic and produces nice layouts for almost any graph. I would recommend to use it as your default choice. Other algorithms for, e.g., concentric layouts and clustered networks are described further down in this tutorial. For the sake of completeness, here is a list of layout algorithms of igraph.\nc(\n  \"layout_with_dh\", \"layout_with_drl\", \"layout_with_fr\",\n  \"layout_with_gem\", \"layout_with_graphopt\", \"layout_with_kk\",\n  \"layout_with_lgl\", \"layout_with_mds\", \"layout_with_sugiyama\",\n  \"layout_as_bipartite\", \"layout_as_star\", \"layout_as_tree\"\n)\nTo use them, you just need the last part of the name.\nggraph(gotS1, layout = \"dh\") +\n  ...\nNote that there technically is no right or wrong choice. All layout algorithms are in a sense arbitrary since we can choose x and y coordinates freely (compare this to ordinary data!). It is all mostly about aesthetics.\nYou can also precompute the layout with the create_layout() function. This makes sense in cases where the calculation of the layout takes very long and you want to play around with other visual aspects.\ngotS1_layout &lt;- create_layout(gotS1 = \"stress\")\n\nggraph(gotS1_layout) +\n  ...",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grammar of Graphs</span>"
    ]
  },
  {
    "objectID": "ggraph-basics.html#edges",
    "href": "ggraph-basics.html#edges",
    "title": "8  Grammar of Graphs",
    "section": "8.3 Edges",
    "text": "8.3 Edges\ngeom_edge_link0(aes(width = weight), edge_colour = \"grey66\")\nThe second layer specifies how to draw the edges. Edges can be drawn in many different ways as the list below shows.\nc(\n  \"geom_edge_arc\", \"geom_edge_arc0\", \"geom_edge_arc2\", \"geom_edge_density\",\n  \"geom_edge_diagonal\", \"geom_edge_diagonal0\", \"geom_edge_diagonal2\",\n  \"geom_edge_elbow\", \"geom_edge_elbow0\", \"geom_edge_elbow2\", \"geom_edge_fan\",\n  \"geom_edge_fan0\", \"geom_edge_fan2\", \"geom_edge_hive\", \"geom_edge_hive0\",\n  \"geom_edge_hive2\", \"geom_edge_link\", \"geom_edge_link0\", \"geom_edge_link2\",\n  \"geom_edge_loop\", \"geom_edge_loop0\"\n)\nYou can do a lot of fancy things with these geoms but for a standard network plot, you should always stick with geom_edge_link0 since it simply draws a straight line between the endpoints. Some tools draw curved edges by default. While this may add some artistic value, it reduces readability. Always go with straight lines! If your network has multiple edges between two nodes, then you can switch to geom_edge_parallel().\nIn case you are wondering what the “0” stands for: The standard geom_edge_link() draws 100 dots on each edge compared to only two dots (the endpoints) in geom_edge_link0(). This is done to allow, e.g., gradients along the edge.\n\n\nWarning: The dot-dot notation (`..index..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(index)` instead.\n\n\n\n\n\n\n\n\n\nYou can reproduce this figure by substituting\ngeom_edge_link(aes(edge_alpha = ..index..), edge_colour = \"black\")\nin the code above.\nThe drawback of using geom_edge_link() is that the time to render the plot increases and so does the size of the file if you export the plot (example) Typically, you do not need gradients along an edge. Hence, geom_edge_link0() should be your default choice to draw edges.\nWithin geom_edge_link0, you can specify the appearance of the edge, either by mapping edge attributes to aesthetics or setting them globally for the graph. Mapping attributes to aesthetics is done within aes(). In the example, we map the edge width to the edge attribute “weight”. ggraph then automatically scales the edge width according to the attribute. The colour of all edges is globally set to “grey66”.\nThe following aesthetics can be used within geom_edge_link0 either within aes() or globally:\n\nedge_colour (colour of the edge)\nedge_linewidth (width of the edge)\nedge_linetype (linetype of the edge, defaults to “solid”)\nedge_alpha (opacity; a value between 0 and 1)\n\nggraph does not automatically draw arrows if your graph is directed. You need to do this manually using the arrow parameter.\ngeom_edge_link0(aes(...), ...,\n  arrow = arrow(\n    angle = 30, length = unit(0.15, \"inches\"),\n    ends = \"last\", type = \"closed\"\n  )\n)\nThe default arrowhead type is “open”, yet “closed” usually has a nicer appearance.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grammar of Graphs</span>"
    ]
  },
  {
    "objectID": "ggraph-basics.html#nodes",
    "href": "ggraph-basics.html#nodes",
    "title": "8  Grammar of Graphs",
    "section": "8.4 Nodes",
    "text": "8.4 Nodes\ngeom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size &gt;= 26, label = name), family = \"serif\")\nOn top of the edge layer, we draw the node layer. Always draw the node layer above the edge layer. Otherwise, edges will be visible on top of nodes. There are slightly less geoms available for nodes.\nc(\n  \"geom_node_arc_bar\", \"geom_node_circle\", \"geom_node_label\",\n  \"geom_node_point\", \"geom_node_text\", \"geom_node_tile\", \"geom_node_treemap\"\n)\nThe most important ones here are geom_node_point() to draw nodes as simple geometric objects (circles, squares,…) and geom_node_text() to add node labels. You can also use geom_node_label(), but this draws labels within a box.\nThe mapping of node attributes to aesthetics is similar to edge attributes. In the example code, we map the fill attribute of the node shape to the “clu” attribute, which holds the result of a clustering, and the size of the nodes to the attribute “size”. The shape of the node is globally set to 21.\nThe figure below shows all possible shapes that can be used for the nodes.\n\nPersonally, I prefer “21” since it draws a border around the nodes. If you prefer another shape, say “19”, you have to be aware of several things. To change the color of shapes 1-20, you need to use the colour parameter. For shapes 21-25 you need to use fill. The colour parameter only controls the border for these cases.\nThe following aesthetics can be used within geom_node_point() either within aes() or globally:\n\nalpha (opacity; a value between 0 and 1)\ncolour (colour of shapes 0-20 and border colour for 21-25)\nfill (fill colour for shape 21-25)\nshape (node shape; a value between 0 and 25)\nsize (size of node)\nstroke (size of node border)\n\nFor geom_node_text(), there are a lot more options available, but the most important once are:\n\nlabel (attribute to be displayed as node label)\ncolour (text colour)\nfamily (font to be used)\nsize (font size)\n\nNote that we also used a filter within aes() of geom_node_text(). The filter parameter allows you to specify a rule for when to apply the aesthetic mappings. The most frequent use case is for node labels (but can also be used for edges or nodes). In the example, we only display the node label if the size attribute is larger than 26.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grammar of Graphs</span>"
    ]
  },
  {
    "objectID": "ggraph-basics.html#scales",
    "href": "ggraph-basics.html#scales",
    "title": "8  Grammar of Graphs",
    "section": "8.5 Scales",
    "text": "8.5 Scales\nscale_fill_manual(values = got_palette) +\n  scale_edge_width_continuous(range = c(0.2, 3)) +\n  scale_size_continuous(range = c(1, 6))\nThe scale_* functions are used to control aesthetics that are mapped within aes(). You do not necessarily need to set them, since ggraph can take care of it automatically.\n\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size &gt;= 26, label = name), family = \"serif\") +\n  theme_graph() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nWhile the node fill and size seem reasonable, the edges are a little too thick. In general, it is always a good idea to add a scale_* for each aesthetic within aes().\nWhat kind of scale_* function you need depends on the aesthetic and on the type of attribute you are mapping. Generally, scale functions are structured like this:\nscale_&lt;aes&gt;_&lt;variable type&gt;().\nThe “aes” part is easy. Just us the type you specified within aes(). For edges, however, you have to prepend edge_. The “variable type” part depends on which scale the attribute is on. Before we continue, it may be a good idea to briefly discuss what aesthetics make sense for which variable type.\n\n\n\n\n\n\n\n\naesthetic\nvariable type\nnotes\n\n\n\n\nnode size\ncontinuous\n\n\n\nedge width\ncontinuous\n\n\n\nnode colour/fill\ncategorical/continuous\nuse a gradient for continuous variables\n\n\nedge colour\ncontinuous\ncategorical only if there are different types of edges\n\n\nnode shape\ncategorical\nonly if there are a few categories (1-5). Colour should be the preferred choice\n\n\nedge linetype\ncategorical\nonly if there are a few categories (1-5). Colour should be the preferred choice\n\n\nnode/edge alpha\ncontinuous\n\n\n\n\nThe easiest to use scales are those for continuous variables mapped to edge width and node size (also the alpha value, which is not used here). While there are several parameters within scale_edge_width_continuous() and scale_size_continuous(), the most important one is “range” which fixes the minimum and maximum width/size. It usually suffices to adjust this parameter.\nFor continuous variables that are mapped to node/edge colour, you can use scale_colour_gradient() scale_colour_gradient2() or scale_colour_gradientn() (add edge_ before colour for edge colours). The difference between these functions is in how the gradient is constructed. gradient creates a two colour gradient (low-high). Simply specify the the two colours to be used (e.g. low = “blue”, high = “red”). gradient2 creates a diverging colour gradient (low-mid-high) (e.g. low = “blue”, mid = “white”, high = “red”) and gradientn a gradient consisting of more than three colours (specified with the colours parameter).\nFor categorical variables that are mapped to node colours (or fill in our example), you can use scale_fill_manual(). This forces you to choose a color for each category yourself. Simply create a vector of colors (see the got_palette) and pass it to the function with the parameter values.\nggraph then assigns the colors in the order of the unique values of the categorical variable. This are either the factor levels (if the variable is a factor) or the result of sorting the unique values (if the variable is a character).\n\nsort(unique(V(gotS1)$clu))\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\"\n\n\nIf you want more control over which value is mapped to which colour, you can pass the vector of colours as a named vector.\n\ngot_palette2 &lt;- c(\n    \"5\" = \"#1A5878\", \"3\" = \"#C44237\", \"2\" = \"#AD8941\",\n    \"1\" = \"#E99093\", \"4\" = \"#50594B\", \"7\" = \"#8968CD\", \"6\" = \"#9ACD32\"\n)\n\n\n\n\n\n\n\n\n\n\nUsing your own colour palette gives your network a unique touch. If you can’t be bothered with choosing colours, you may want to consider scale_fill_brewer() and scale_colour_brewer(). The function offers all palettes available at colorbrewer2.org.\n\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size &gt;= 26, label = name), family = \"serif\") +\n  scale_fill_brewer(palette = \"Dark2\") +\n  scale_edge_width_continuous(range = c(0.2, 3)) +\n  scale_size_continuous(range = c(1, 6)) +\n  theme_graph() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n(Check out this github repo from Emil Hvitfeldt for a comprehensive list of color palettes available in R)",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grammar of Graphs</span>"
    ]
  },
  {
    "objectID": "ggraph-basics.html#themes",
    "href": "ggraph-basics.html#themes",
    "title": "8  Grammar of Graphs",
    "section": "8.6 Themes",
    "text": "8.6 Themes\ntheme_graph() +\n  theme(legend.position = \"none\")\nthemes control the overall look of the plot. There are a lot of options within the theme() function of ggplot2. Luckily, we really don’t need any of those. theme_graph() is used to erase all of the default ggplot theme (e.g. axis, background, grids, etc.) since they are irrelevant for networks. The only option worthwhile in theme() is legend.position, which we set to “none”, i.e. don’t show the legend.\nThe code below gives an example for a plot with a legend.\n\nggraph(gotS1, layout = \"stress\") +\n  geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n  geom_node_point(aes(fill = clu, size = size), shape = 21) +\n  geom_node_text(aes(filter = size &gt;= 26, label = name), family = \"serif\") +\n  scale_fill_manual(values = got_palette) +\n  scale_edge_width_continuous(range = c(0.2, 3)) +\n  scale_size_continuous(range = c(1, 6)) +\n  theme_graph() +\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grammar of Graphs</span>"
    ]
  },
  {
    "objectID": "example-viz.html",
    "href": "example-viz.html",
    "title": "9  Example Visualizations",
    "section": "",
    "text": "9.1 Greys Anatomy\nLet us work through one visualization using a very special data set. The “Grey’s Anatomy” hook-up network\ndata(\"greys\")\nStart with the autograph call.\nautograph(greys)\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\nThe network consists of several components. Note that the igraph standard is to pack all components in a circle. The standard in graphlayouts is to arrange them in a rectangle. You can specify the bbox parameter to arrange the components differently. The plot above arranges all components on one level, but two levels may be desirable. You may need to experiment a bit with the parameter, but for this network, bbox=15 seems to work best (see below).\nWe will use this network to quickly illustrate what can be done with geom_edge_link2(). The function allows to interpolate node attributes between the start and end node along the edges. In the code below, we use the “position” attribute. The line which adds the node labels illustrates two further features of ggraph. First, aesthetics don’t need to be node attributes. Here, for instance, we calculate the degree and then map it to the font size. The second one is the repel = TRUE argument. This option places the node labels in a way that labels do not overlap.\nggraph(greys, \"stress\", bbox = 15) +\n    geom_edge_link2(aes(edge_colour = node.position), edge_linewidth = 0.5) +\n    geom_node_point(aes(fill = sex), shape = 21, size = 3) +\n    geom_node_text(aes(label = name, size = degree(greys)),\n        family = \"serif\", repel = TRUE\n    ) +\n    scale_edge_colour_brewer(palette = \"Set1\") +\n    scale_fill_manual(values = c(\"grey66\", \"#EEB422\", \"#424242\")) +\n    scale_size(range = c(2, 5), guide = \"none\") +\n    theme_graph() +\n    theme(legend.position = \"bottom\")\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\nWhile the coloured edges look kind of artistic, we should go back to the “0” version.\nggraph(greys, \"stress\", bbox = 15) +\n    geom_edge_link0(edge_colour = \"grey66\", edge_linewidth = 0.5) +\n    geom_node_point(aes(fill = sex), shape = 21, size = 3) +\n    geom_node_text(aes(label = name, size = degree(greys)),\n        family = \"serif\", repel = TRUE\n    ) +\n    scale_fill_manual(values = c(\"grey66\", \"#EEB422\", \"#424242\")) +\n    scale_size(range = c(2, 5), guide = \"none\") +\n    theme_graph() +\n    theme(legend.position = \"bottom\")",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Example Visualizations</span>"
    ]
  },
  {
    "objectID": "example-viz.html#recreate-the-polblogs-viz",
    "href": "example-viz.html#recreate-the-polblogs-viz",
    "title": "9  Example Visualizations",
    "section": "9.2 Recreate the polblogs viz",
    "text": "9.2 Recreate the polblogs viz\nIn this section, we do a little code through to recreate the figure shown below.\n The network shows the linking between political blogs during the 2004 election in the US. Red nodes are conservative leaning blogs and blue ones liberal.\nThe dataset is included in the networkdata package.\n\ndata(\"polblogs\")\n\n## add a vertex attribute for the indegree\nV(polblogs)$deg &lt;- degree(polblogs, mode = \"in\")\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\n\n\nLet us start with a simple plot without any styling.\n\nlay &lt;- create_layout(polblogs, \"stress\")\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, edge_colour = \"grey66\",\n        arrow = arrow(\n            angle = 15, length = unit(0.15, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point()\n\n\n\n\n\n\n\n\nThere is obviously a lot missing. First, we delete all isolates and plot again.\n\npolblogs &lt;- delete.vertices(polblogs, which(degree(polblogs) == 0))\nlay &lt;- create_layout(polblogs, \"stress\")\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, edge_colour = \"grey66\",\n        arrow = arrow(\n            angle = 15, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point()\n\n\n\n\n\n\n\n\nThe original does feature a small disconnected component, but we remove this here.\n\ncomps &lt;- components(polblogs)\npolblogs &lt;- delete.vertices(polblogs, which(comps$membership == which.min(comps$csize)))\n\nlay &lt;- create_layout(polblogs, \"stress\")\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, edge_colour = \"grey66\",\n        arrow = arrow(\n            angle = 15, length = unit(0.15, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point()\n\n\n\n\n\n\n\n\nBetter, let’s start with some styling of the nodes.\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, edge_colour = \"grey66\",\n        arrow = arrow(\n            angle = 15, length = unit(0.15, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol))\n\n\n\n\n\n\n\n\nThe colors are obviously wrong, so we fix this with a scale_fill_manual(). Additionally, we map the degree to node size.\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, edge_colour = \"grey66\",\n        arrow = arrow(\n            angle = 15, length = unit(0.15, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol, size = deg), show.legend = FALSE) +\n    scale_fill_manual(values = c(\"left\" = \"#104E8B\", \"right\" = \"firebrick3\"))\n\n\n\n\n\n\n\n\nThe node sizes are also not that satisfactory, so we fix the range with scale_size().\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, edge_colour = \"grey66\",\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol, size = deg), show.legend = FALSE) +\n    scale_fill_manual(values = c(\"left\" = \"#104E8B\", \"right\" = \"firebrick3\")) +\n    scale_size(range = c(0.5, 7))\n\n\n\n\n\n\n\n\nNow we move on to the edges. This is a bit more complicated since we have to create an edge variable first which indicates if an edge is within or between political orientations. This new variable is mapped to the edge color.\n\nel &lt;- get.edgelist(polblogs, names = FALSE)\nel_pol &lt;- cbind(V(polblogs)$pol[el[, 1]], V(polblogs)$pol[el[, 2]])\nE(polblogs)$col &lt;- ifelse(el_pol[, 1] == el_pol[, 2], el_pol[, 1], \"mixed\")\n\n\nlay &lt;- create_layout(polblogs, \"stress\")\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, aes(edge_colour = col),\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        )\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol, size = deg), show.legend = FALSE) +\n    scale_fill_manual(values = c(\"left\" = \"#104E8B\", \"right\" = \"firebrick3\")) +\n    scale_size(range = c(0.5, 7))\n\n\n\n\n\n\n\n\nSimilar to the node colors, we add a scale_edge_colour_manual() to adjust the edge colors.\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, aes(edge_colour = col),\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        ), show.legend = FALSE\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol, size = deg), show.legend = FALSE) +\n    scale_fill_manual(values = c(\"left\" = \"#104E8B\", \"right\" = \"firebrick3\")) +\n    scale_edge_colour_manual(values = c(\"left\" = \"#104E8B\", \"mixed\" = \"goldenrod\", \"right\" = \"firebrick3\")) +\n    scale_size(range = c(0.5, 7))\n\n\n\n\n\n\n\n\nAlmost, but it seems there are a lot of yellow edges which run over blue edges. It looks as if these should run below according to the original viz. To achieve this, we use a filter trick. We add two geom_edge_link0() layers: First, for the mixed edges and then for the remaining edges. In that way, the mixed edges are getting plotted below.\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, aes(filter = (col == \"mixed\"), edge_colour = col),\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        ), show.legend = FALSE\n    ) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, aes(filter = (col != \"mixed\"), edge_colour = col),\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        ), show.legend = FALSE\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol, size = deg), show.legend = FALSE) +\n    scale_fill_manual(values = c(\"left\" = \"#104E8B\", \"right\" = \"firebrick3\")) +\n    scale_edge_colour_manual(values = c(\"left\" = \"#104E8B\", \"mixed\" = \"goldenrod\", \"right\" = \"firebrick3\")) +\n    scale_size(range = c(0.5, 7))\n\n\n\n\n\n\n\n\nNow lets just add the theme_graph().\n\nggraph(lay) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, aes(filter = (col == \"mixed\"), edge_colour = col),\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        ), show.legend = FALSE\n    ) +\n    geom_edge_link0(\n        edge_linewidth = 0.2, aes(filter = (col != \"mixed\"), edge_colour = col),\n        arrow = arrow(\n            angle = 10, length = unit(0.1, \"inches\"),\n            ends = \"last\", type = \"closed\"\n        ), show.legend = FALSE\n    ) +\n    geom_node_point(shape = 21, aes(fill = pol, size = deg), show.legend = FALSE) +\n    scale_fill_manual(values = c(\"left\" = \"#104E8B\", \"right\" = \"firebrick3\")) +\n    scale_edge_colour_manual(values = c(\"left\" = \"#104E8B\", \"mixed\" = \"goldenrod\", \"right\" = \"firebrick3\")) +\n    scale_size(range = c(0.5, 7)) +\n    theme_graph()",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Example Visualizations</span>"
    ]
  },
  {
    "objectID": "enhance-viz.html",
    "href": "enhance-viz.html",
    "title": "10  Enhancing Visualizations",
    "section": "",
    "text": "10.1 Miscellaneous\nEverything we covered so far should be enough to produce nice network visualizations for scientific publications. However, ggraph has a lot more advanced functions/parameter settings to further enhance your visualization. If you are looking for something specific, it is always a good idea to read the documentation of the geoms.\nSome things that I frequently use are the following:\nThe stress layout also works well with medium to large graphs.\nThe network shows the biggest componentn of the co-authorship network of R package developers on CRAN (~12k nodes)\nIf you want to go beyond ~20k nodes, then you may want to switch to layout_with_pmds() or layout_with_sparse_stress() which are optimized to work with large graphs.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Enhancing Visualizations</span>"
    ]
  },
  {
    "objectID": "enhance-viz.html#miscellaneous",
    "href": "enhance-viz.html#miscellaneous",
    "title": "10  Enhancing Visualizations",
    "section": "",
    "text": "change the end_cap in geom_edge_link() to end edges before reaching the node. This is helpful for directed edges to not make the arrows disappear.\nlegend.position in theme() controls all legends at once. If you don’t want to show a specific legend, use guide = \"none\" in the respective scale_* function.\nuse scale_color_viridis_c() and scale_color_viridis_d(). The viridis colour palette makes plots easier to read by those with colorblindness and print well in grey scale.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Enhancing Visualizations</span>"
    ]
  },
  {
    "objectID": "enhance-viz.html#use-the-ggforce",
    "href": "enhance-viz.html#use-the-ggforce",
    "title": "10  Enhancing Visualizations",
    "section": "10.2 use the ggforce",
    "text": "10.2 use the ggforce\nThe ggforce package works pretty nicely with ggraph. You can, for instance, use the geom_mark_*() functions to highlight clusters.\n\nset.seed(665)\n\n## create network with a group structure\ng &lt;- sample_islands(9, 40, 0.4, 15)\ng &lt;- igraph::simplify(g)\nV(g)$grp &lt;- as.character(rep(1:9, each = 40))\n\nbb &lt;- layout_as_backbone(g, keep = 0.4)\nE(g)$col &lt;- F\nE(g)$col[bb$backbone] &lt;- T\n\n\nggraph(g, #|\n    layout = \"manual\",\n    x = bb$xy[, 1],\n    y = bb$xy[, 2]\n) +\n    geom_edge_link0(aes(col = col), width = 0.2) +\n    geom_node_point(aes(fill = grp), shape = 21, size = 3) +\n    geom_mark_hull(\n        aes(x, y, group = grp, fill = grp),\n        concavity = 4,\n        expand = unit(2, \"mm\"),\n        alpha = 0.25\n    ) +\n    scale_color_brewer(palette = \"Set1\") +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme_graph() +\n    theme(legend.position = \"none\")\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\n\nOf course you can also add a label to your clusters.\n\nggraph(g, #|\n    layout = \"manual\",\n    x = bb$xy[, 1],\n    y = bb$xy[, 2]\n) +\n    geom_edge_link0(aes(col = col), width = 0.2) +\n    geom_node_point(aes(fill = grp), shape = 21, size = 3) +\n    geom_mark_hull(\n        aes(x, y, group = grp, fill = grp, label = grp),\n        concavity = 4,\n        expand = unit(2, \"mm\"),\n        alpha = 0.25\n    ) +\n    scale_color_brewer(palette = \"Set1\") +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme_graph() +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nIf you want to avoid node overlaps, you can use geom_node_voronoi(). So this is actually already implemented in {{ggraph}}, but originates from geom_voronoi_tile().\n\nggraph(g,\n    layout = \"manual\",\n    x = bb$xy[, 1],\n    y = bb$xy[, 2]\n) +\n    geom_edge_link0(aes(filter = !col, col = col), width = 0.2) +\n    geom_node_voronoi(\n        aes(x, y, fill = grp),\n        max.radius = 0.4,\n        expand = unit(-0.5, \"mm\"),\n        colour = \"black\"\n    ) +\n    scale_color_brewer(palette = \"Set1\") +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme(\n        legend.position = \"none\",\n        panel.grid = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text = element_blank()\n    ) +\n    theme_graph() +\n    theme(legend.position = \"none\")",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Enhancing Visualizations</span>"
    ]
  },
  {
    "objectID": "enhance-viz.html#small-tricks-for-common-problems",
    "href": "enhance-viz.html#small-tricks-for-common-problems",
    "title": "10  Enhancing Visualizations",
    "section": "10.3 Small tricks for common problems",
    "text": "10.3 Small tricks for common problems\n\n“How can I achieve that my directed edges stop at the node border, independent from the node size?”\n\nThis one has given me headaches for the longest time. No matter what I tried, I always ended up with something like the below plot.\n\n## create a random network\nset.seed(1071)\ng &lt;- sample_pa(30, 1)\nV(g)$degree &lt;- degree(g, mode = \"in\")\n\nggraph(g, \"stress\") +\n    geom_edge_link(\n        aes(end_cap = circle(node2.degree + 2, \"pt\")),\n        edge_colour = \"black\",\n        arrow = arrow(\n            angle = 10,\n            length = unit(0.15, \"inches\"),\n            ends = \"last\",\n            type = \"closed\"\n        )\n    ) +\n    geom_node_point(aes(size = degree), col = \"grey66\", show.legend = FALSE) +\n    scale_size(range = c(3, 11)) +\n    theme_graph()\n\n\n\n\n\n\n\n\nThe overlap can be avoided by using the I() function from base R, which treats the entries of a vector “as is”. So we know that if a node has degree 5, it will be mapped to a circle with radius (or diameter?) “5pt”. Since this means, that you have no control over the scaling, you need to do that beforehand.\n\n## this function is borrowed from the ambient package\nnormalise &lt;- function(x, from = range(x), to = c(0, 1)) {\n    x &lt;- (x - from[1]) / (from[2] - from[1])\n    if (!identical(to, c(0, 1))) {\n        x &lt;- x * (to[2] - to[1]) + to[1]\n    }\n    x\n}\n\n## map to the range you want\nV(g)$degree &lt;- normalise(V(g)$degree, to = c(3, 11))\n\nggraph(g, \"stress\") +\n    geom_edge_link(\n        aes(end_cap = circle(node2.degree + 2, \"pt\")),\n        edge_colour = \"grey25\",\n        arrow = arrow(\n            angle = 10,\n            length = unit(0.15, \"inches\"),\n            ends = \"last\",\n            type = \"closed\"\n        )\n    ) +\n    geom_node_point(aes(size = I(degree)), col = \"grey66\") +\n    theme_graph()\n\n\n\n\n\n\n\n\nI would not be surprised though if there is an even easier fix for this problem.\n\n“How can I lower the opacity of nodes without making edges visible underneath?”\n\nOne of the rules I try to follow is that edges should not be visible on top of nodes. Usually that is easy to achieve by drawing the edges before the nodes. But if you want to lower the opacity of nodes, they do become visible again.\n\ng &lt;- sample_gnp(20, 0.5)\nV(g)$degree &lt;- degree(g)\n\nggraph(g, \"stress\") +\n    geom_edge_link(edge_colour = \"grey66\") +\n    geom_node_point(\n        size = 8,\n        aes(alpha = degree),\n        col = \"red\",\n        show.legend = FALSE\n    ) +\n    theme_graph()\n\n\n\n\n\n\n\n\nThe solution is rather simple. Just add a node layer with the same aesthetics below with alpha=1 (default) and color=\"white\" (or the background color of the plot).\n\nggraph(g, \"stress\") +\n    geom_edge_link(edge_colour = \"grey66\") +\n    geom_node_point(size = 8, col = \"white\") +\n    geom_node_point(\n        aes(alpha = degree),\n        size = 8,\n        col = \"red\",\n        show.legend = FALSE\n    ) +\n    theme_graph()\n\n\n\n\n\n\n\n\nOf course you could also use start_cap and end_cap here, but you may have to fiddle again as in the last example.\n\n“How can I enhance readability of node labels in hairball graphs?”\n\nSometimes it is really hard to make labels readable when the network is very cluttered\n\ng &lt;- sample_gnp(50, 0.7)\nV(g)$name &lt;- sapply(1:50, function(x) paste0(sample(LETTERS, 4), collapse = \"\"))\nE(g)$weight &lt;- runif(ecount(g))\n\nggraph(g) +\n    geom_edge_link0(aes(edge_color = weight, edge_linewidth = weight), show.legend = FALSE) +\n    geom_node_point(size = 8, color = \"#44a6c6\") +\n    geom_node_text(aes(label = name), fontface = \"bold\") +\n    scale_edge_color_continuous(low = \"grey66\", high = \"black\") +\n    scale_edge_width(range = c(0.1, 0.5)) +\n    theme_graph() +\n    coord_fixed()\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\nHere you can make use of the fact that the layout of the nodes are stored in a “hidden” data frame when a ggraph object is constructed. That means you can use other geoms from other packages. In this case, the shadowtext package as shown below.\n\nggraph(g, \"stress\") +\n    geom_edge_link0(aes(edge_color = weight, edge_linewidth = weight), show.legend = FALSE) +\n    geom_node_point(size = 8, color = \"#44a6c6\") +\n    shadowtext::geom_shadowtext(aes(x, y, label = name), color = \"black\", size = 4, bg.colour = \"white\") +\n    scale_edge_color_continuous(low = \"grey66\", high = \"black\") +\n    scale_edge_width(range = c(0.1, 0.5)) +\n    theme_graph() +\n    coord_fixed()",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Enhancing Visualizations</span>"
    ]
  },
  {
    "objectID": "enhance-viz.html#snahelper",
    "href": "enhance-viz.html#snahelper",
    "title": "10  Enhancing Visualizations",
    "section": "10.4 snahelper",
    "text": "10.4 snahelper\nEven with a lot of experience, it may still be a painful process to produce nice looking figures by writing ggraph code. Enter the snahelper.\ninstall.packages(\"snahelper\")\nThe snahelper is an RStudio addin which provides you with a GUI to plot networks. Instead of writing code, you simply use drop-down menus to assign attributes to aesthetics or change appearances globally. One great feature of the addin is that you can adjust the position of nodes individually if you are not satisfied with their location. Once you are done, you can either directly export the figure to png or automatically insert the code to produce the figure into your script. That way, you can review the code and hopefully learn something from it. Below if a demo that shows its functionality.\n\nTo use the addin, simply highlight the variable name of your network within an R script and choose the SNAhelper from the Addins drop-down menu within RStudio. You can find more about the Addin on its dedicated pkgdown page",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Enhancing Visualizations</span>"
    ]
  },
  {
    "objectID": "advanced-viz.html",
    "href": "advanced-viz.html",
    "title": "11  Advanced Layouts",
    "section": "",
    "text": "11.1 Concentric layouts\nCircular layouts are generally not advisable. Concentric circles, on the other hand, help to emphasize the position of certain nodes in the network. The graphlayouts package has two function to create concentric layouts, layout_with_focus() and layout_with_centrality().\nThe first one allows to focus the network on a specific node and arrange all other nodes in concentric circles (depending on the geodesic distance) around it. Below we focus on the character Ned Stark.\nggraph(gotS1, layout = \"focus\", focus = 1) +\n    geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n    geom_node_point(aes(fill = clu, size = size), shape = 21) +\n    geom_node_text(aes(filter = (name == \"Ned\"), size = size, label = name),\n        family = \"serif\"\n    ) +\n    scale_edge_width_continuous(range = c(0.2, 1.2)) +\n    scale_size_continuous(range = c(1, 5)) +\n    scale_fill_manual(values = got_palette) +\n    coord_fixed() +\n    theme_graph() +\n    theme(legend.position = \"none\")\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\nThe parameter focus in the first line is used to choose the node id of the focal node. The function coord_fixed() is used to always keep the aspect ratio at one (i.e. the circles are always displayed as a circle and not an ellipse).\nThe function draw_circle() can be used to add the circles explicitly.\nggraph(gotS1, layout = \"focus\", focus = 1) +\n    draw_circle(col = \"#00BFFF\", use = \"focus\", max.circle = 3) +\n    geom_edge_link0(aes(width = weight), edge_colour = \"grey66\") +\n    geom_node_point(aes(fill = clu, size = size), shape = 21) +\n    geom_node_text(aes(filter = (name == \"Ned\"), size = size, label = name),\n        family = \"serif\"\n    ) +\n    scale_edge_width_continuous(range = c(0.2, 1.2)) +\n    scale_size_continuous(range = c(1, 5)) +\n    scale_fill_manual(values = got_palette) +\n    coord_fixed() +\n    theme_graph() +\n    theme(legend.position = \"none\")\nlayout_with_centrality() works in a similar way. You can specify any centrality index (or any numeric vector for that matter), and create a concentric layout where the most central nodes are put in the center and the most peripheral nodes in the biggest circle. The numeric attribute used for the layout is specified with the cent parameter. Here, we use the weighted degree of the characters.\nggraph(gotS1, layout = \"centrality\", cent = graph.strength(gotS1)) +\n    geom_edge_link0(aes(edge_linewidth = weight), edge_colour = \"grey66\") +\n    geom_node_point(aes(fill = clu, size = size), shape = 21) +\n    geom_node_text(aes(size = size, label = name), family = \"serif\") +\n    scale_edge_width_continuous(range = c(0.2, 0.9)) +\n    scale_size_continuous(range = c(1, 8)) +\n    scale_fill_manual(values = got_palette) +\n    coord_fixed() +\n    theme_graph() +\n    theme(legend.position = \"none\")\n(Concentric layouts are not only helpful to focus on specific nodes, but also make for a good tool to visualize ego networks.)",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Advanced Layouts</span>"
    ]
  },
  {
    "objectID": "advanced-viz.html#backbone-layout",
    "href": "advanced-viz.html#backbone-layout",
    "title": "11  Advanced Layouts",
    "section": "11.2 Backbone layout",
    "text": "11.2 Backbone layout\nlayout_as_backbone() is a layout algorithm that can help emphasize hidden group structures. To illustrate the performance of the algorithm, we create an artificial network with a subtle group structure using sample_islands() from igraph.\n\ng &lt;- sample_islands(9, 40, 0.4, 15)\ng &lt;- simplify(g)\nV(g)$grp &lt;- as.character(rep(1:9, each = 40))\n\nThe network consists of 9 groups with 40 vertices each. The density within each group is 0.4 and there are 15 edges running between each pair of groups. Let us try to visualize the network with what we have learned so far.\n\nggraph(g, layout = \"stress\") +\n    geom_edge_link0(edge_colour = \"black\", edge_linewidth = 0.1, edge_alpha = 0.5) +\n    geom_node_point(aes(fill = grp), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\") +\n    theme_graph() +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nAs you can see, the graph seems to be a proper “hairball” without any special structural features standing out. In this case, though, we know that there should be 9 groups of vertices that are internally more densely connected than externally. To uncover this group structure, we turn to the “backbone layout”.\n\nbb &lt;- layout_as_backbone(g, keep = 0.4)\nE(g)$col &lt;- FALSE\nE(g)$col[bb$backbone] &lt;- TRUE\n\nThe idea of the algorithm is as follows. For each edge, an embededness score is calculated which serves as an edge weight attribute. These weights are then ordered and only the edges with the highest score are kept. The number of edges to keep is controlled with the keep parameter. In our example, we keep the top 40%. The parameter usually requires some experimenting to find out what works best. Since this may result in an unconnected network, we add all edges of the union of all maximum spanning trees. The resulting network is the “backbone” of the original network and the “stress” layout algorithm is applied to this network. Once the layout is calculated, all edges are added back to the network.\nThe output of the function are the x and y coordinates for nodes and a vector that gives the ids of the edges in the backbone network. In the code above, we use this vector to create a binary edge attribute that indicates if an edge is part of the backbone or not.\nTo use the coordinates, we set the layout parameter to “manual” and provide the x and y coordinates as parameters.\n\nggraph(g, layout = \"manual\", x = bb$xy[, 1], y = bb$xy[, 2]) +\n    geom_edge_link0(aes(edge_colour = col), edge_linewidth = 0.1) +\n    geom_node_point(aes(fill = grp), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\") +\n    scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.3), rgb(0, 0, 0, 1))) +\n    theme_graph() +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nThe groups are now clearly visible! Of course the network used in the example is specifically tailored to illustrate the power of the algorithm. Using the backbone layout in real world networks may not always result in such a clear division of groups. It should thus not be seen as a universal remedy for drawing hairball networks. Keep in mind: It can only emphasize a hidden group structure if it exists.\nThe plot below shows an empirical example where the algorithm was able to uncover a hidden group structure. The network shows facebook friendships of a university in the US. Node colour corresponds to dormitory of students. Left is the ordinary stress layout and right the backbone layout.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Advanced Layouts</span>"
    ]
  },
  {
    "objectID": "advanced-viz.html#dynamic-networks",
    "href": "advanced-viz.html#dynamic-networks",
    "title": "11  Advanced Layouts",
    "section": "11.3 Dynamic networks",
    "text": "11.3 Dynamic networks\nPeople regularly ask me if it is possible to animate a network evolution with ggraph and gganimate. Unfortunately this is not yet possible. But fear not! There is a way to still get it done with some hacking around the ggraph package. I will walk through this hack below but hope that it will eventually become obsolete.\nFor this part of the tutorial, you will need two additional packages.\n\nlibrary(gganimate)\nlibrary(ggplot2)\nlibrary(patchwork)\n\nWe will be using the 50 actor excerpt from the Teenage Friends and Lifestyle Study from the RSiena data repository as an example. The data is part of the networkdata package.\n\ndata(\"s50\")\n\nThe dataset consists of three networks with 50 actors each and a vertex attribute for the smoking behaviour of students. As a first step, we need to create a layout for all three networks. You can basically use any type of layout for each network, but I’d recommend layout_as_dynamic() from my very own package {{graphlayouts}}. The algorithm calculates a reference layout which is a layout of the union of all networks and individual layouts based on stress minimization and combines those in a linear combination which is controlled by the alpha parameter. For alpha=1, only the reference layout is used and all graphs have the same layout. For alpha=0, the stress layout of each individual graph is used. Values in-between interpolate between the two layouts.\n\nxy &lt;- layout_as_dynamic(s50, alpha = 0.2)\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\n\n\nNow you could use {{ggraph}} and {{patchwork}} to produce a static plot with all networks side-by-side.\n\npList &lt;- vector(\"list\", length(s50))\n\nfor (i in 1:length(s50)) {\n    pList[[i]] &lt;- ggraph(s50[[i]], layout = \"manual\", x = xy[[i]][, 1], y = xy[[i]][, 2]) +\n        geom_edge_link0(edge_linewidth = 0.6, edge_colour = \"grey66\") +\n        geom_node_point(shape = 21, aes(fill = as.factor(smoke)), size = 6) +\n        geom_node_text(label = 1:50, repel = FALSE, color = \"white\", size = 4) +\n        scale_fill_manual(\n            values = c(\"forestgreen\", \"grey25\", \"firebrick\"),\n            guide = ifelse(i != 2, \"none\", \"legend\"),\n            name = \"smoking\",\n            labels = c(\"never\", \"occasionally\", \"regularly\")\n        ) +\n        theme_graph() +\n        theme(legend.position = \"bottom\") +\n        labs(title = paste0(\"Wave \", i))\n}\n\nwrap_plots(pList)\n\n\n\n\n\n\n\n\nThis is nice but of course we want to animate the changes. This is where we say goodbye to ggraph and hello to good-old ggplot2. First, we create a list of data frames for all nodes and add the layout to it.\n\nnodes_lst &lt;- lapply(1:length(s50), function(i) {\n    cbind(igraph::as_data_frame(s50[[i]], \"vertices\"),\n        x = xy[[i]][, 1], y = xy[[i]][, 2], frame = i\n    )\n})\n\nThis was the easy part, because all nodes are present in all time frames so there is not much to do. Edges will be a lot trickier.\n\nedges_lst &lt;- lapply(1:length(s50), function(i) {\n    cbind(igraph::as_data_frame(s50[[i]], \"edges\"), frame = i)\n})\n\nedges_lst &lt;- lapply(1:length(s50), function(i) {\n    edges_lst[[i]]$x &lt;- nodes_lst[[i]]$x[match(edges_lst[[i]]$from, nodes_lst[[i]]$name)]\n    edges_lst[[i]]$y &lt;- nodes_lst[[i]]$y[match(edges_lst[[i]]$from, nodes_lst[[i]]$name)]\n    edges_lst[[i]]$xend &lt;- nodes_lst[[i]]$x[match(edges_lst[[i]]$to, nodes_lst[[i]]$name)]\n    edges_lst[[i]]$yend &lt;- nodes_lst[[i]]$y[match(edges_lst[[i]]$to, nodes_lst[[i]]$name)]\n    edges_lst[[i]]$id &lt;- paste0(edges_lst[[i]]$from, \"-\", edges_lst[[i]]$to)\n    edges_lst[[i]]$status &lt;- TRUE\n    edges_lst[[i]]\n})\n\nhead(edges_lst[[1]])\n\n  from  to frame        x         y     xend      yend     id status\n1   V1 V11     1  1.57587  0.819774  1.91554 -0.156128 V1-V11   TRUE\n2   V1 V14     1  1.57587  0.819774  2.15845  0.803542 V1-V14   TRUE\n3   V2  V7     1  3.45088 -0.657500  3.71981 -1.272365  V2-V7   TRUE\n4   V2 V11     1  3.45088 -0.657500  1.91554 -0.156128 V2-V11   TRUE\n5   V3  V4     1 -5.06301 -2.136275 -4.04555 -2.334361  V3-V4   TRUE\n6   V3  V9     1 -5.06301 -2.136275 -5.60509 -2.843401  V3-V9   TRUE\n\n\nWe have expanded the edge data frame in a way that also includes the coordinates of the endpoints from the layout that we calculated earlier.\nNow we create a helper matrix which includes all edges that are present in any of the networks\n\nall_edges &lt;- do.call(\"rbind\", lapply(s50, get.edgelist))\nall_edges &lt;- all_edges[!duplicated(all_edges), ]\nall_edges &lt;- cbind(all_edges, paste0(all_edges[, 1], \"-\", all_edges[, 2]))\n\nThis is used to impute the edges into all networks. So any edge that is not present in time frame two and three gets added to time frame one. But to keep track of these, we set there status to FALSE.\n\nedges_lst &lt;- lapply(1:length(s50), function(i) {\n    idx &lt;- which(!all_edges[, 3] %in% edges_lst[[i]]$id)\n    if (length(idx != 0)) {\n        tmp &lt;- data.frame(from = all_edges[idx, 1], to = all_edges[idx, 2], id = all_edges[idx, 3])\n        tmp$x &lt;- nodes_lst[[i]]$x[match(tmp$from, nodes_lst[[i]]$name)]\n        tmp$y &lt;- nodes_lst[[i]]$y[match(tmp$from, nodes_lst[[i]]$name)]\n        tmp$xend &lt;- nodes_lst[[i]]$x[match(tmp$to, nodes_lst[[i]]$name)]\n        tmp$yend &lt;- nodes_lst[[i]]$y[match(tmp$to, nodes_lst[[i]]$name)]\n        tmp$frame &lt;- i\n        tmp$status &lt;- FALSE\n        edges_lst[[i]] &lt;- rbind(edges_lst[[i]], tmp)\n    }\n    edges_lst[[i]]\n})\n\nWhy are we doing this? After a lot of experimenting, I came to the conclusion that it is always best to draw all edges, but use zero opacity if status = FALSE. In that way, one gets a smoother transition for edges that (dis)appear. There are probably other workarounds though.\nIn the last step, we create a data frame out of the lists.\n\nedges_df &lt;- do.call(\"rbind\", edges_lst)\nnodes_df &lt;- do.call(\"rbind\", nodes_lst)\n\nhead(edges_df)\n\n  from  to frame        x         y     xend      yend     id status\n1   V1 V11     1  1.57587  0.819774  1.91554 -0.156128 V1-V11   TRUE\n2   V1 V14     1  1.57587  0.819774  2.15845  0.803542 V1-V14   TRUE\n3   V2  V7     1  3.45088 -0.657500  3.71981 -1.272365  V2-V7   TRUE\n4   V2 V11     1  3.45088 -0.657500  1.91554 -0.156128 V2-V11   TRUE\n5   V3  V4     1 -5.06301 -2.136275 -4.04555 -2.334361  V3-V4   TRUE\n6   V3  V9     1 -5.06301 -2.136275 -5.60509 -2.843401  V3-V9   TRUE\n\nhead(nodes_df)\n\n   name smoke        x         y frame\nV1   V1     2  1.57587  0.819774     1\nV2   V2     3  3.45088 -0.657500     1\nV3   V3     1 -5.06301 -2.136275     1\nV4   V4     1 -4.04555 -2.334361     1\nV5   V5     1 -2.98171 -2.913892     1\nV6   V6     1 -1.59806 -4.780603     1\n\n\nAnd that’s it in terms of data wrangling. All that is left is to plot/animate the data.\nggplot() +\n  geom_segment(\n    data = edges_df,\n    aes(x = x, xend = xend, y = y, yend = yend, group = id, alpha = status),\n    show.legend = FALSE\n  ) +\n  geom_point(\n    data = nodes_df, aes(x, y, group = name, fill = as.factor(smoke)),\n    shape = 21, size = 4, show.legend = FALSE\n  ) +\n  scale_fill_manual(values = c(\"forestgreen\", \"grey25\", \"firebrick\")) +\n  scale_alpha_manual(values = c(0, 1)) +\n  ease_aes(\"quadratic-in-out\") +\n  transition_states(frame, state_length = 0.5, wrap = FALSE) +\n  labs(title = \"Wave {closest_state}\") +\n  theme_void()",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Advanced Layouts</span>"
    ]
  },
  {
    "objectID": "advanced-viz.html#multilevel-networks",
    "href": "advanced-viz.html#multilevel-networks",
    "title": "11  Advanced Layouts",
    "section": "11.4 Multilevel networks",
    "text": "11.4 Multilevel networks\nIn this section, you will get to know layout_as_multilevel(), a layout algorithm in the raphlayouts package which can be use to visualize multilevel networks.\nA multilevel network consists of two (or more) levels with different node sets and intra-level ties. For instance, one level could be scientists and their collaborative ties and the second level are labs and ties among them, and inter-level edges are the affiliations of scientists and labs.\nThe graphlayouts package contains an artificial multilevel network which will be used to illustrate the algorithm.\n\ndata(\"multilvl_ex\")\n\nThe package assumes that a multilevel network has a vertex attribute called lvl which holds the level information (1 or 2).\nThe underlying algorithm of layout_as_multilevel() has three different versions, which can be used to emphasize different structural features of a multilevel network.\nIndependent of which option is chosen, the algorithm internally produces a 3D layout, where each level is positioned on a different y-plane. The 3D layout is then mapped to 2D with an isometric projection. The parameters alpha and beta control the perspective of the projection. The default values seem to work for many instances, but may not always be optimal. As a rough guideline: beta rotates the plot around the y axis (in 3D) and alpha moves the POV up or down.\n\n11.4.0.1 Complete layout\nA layout for the complete network can be computed via layout_as_multilevel() setting type = \"all\". Internally, the algorithm produces a constrained 3D stress layout (each level on a different y plane) which is then projected to 2D. This layout ignores potential differences in each level and optimizes only the overall layout.\n\nxy &lt;- layout_as_multilevel(multilvl_ex, type = \"all\", alpha = 25, beta = 45)\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\n\n\nTo visualize the network with ggraph, you may want to draw the edges for each level (and inter level edges) with a different edge geom. This gives you more flexibility to control aesthetics and can easily be achieved with a filter.\n\nggraph(multilvl_ex, \"manual\", x = xy[, 1], y = xy[, 2]) +\n    geom_edge_link0(\n        aes(filter = (node1.lvl == 1 & node2.lvl == 1)),\n        edge_colour = \"firebrick3\",\n        alpha = 0.5,\n        edge_linewidth = 0.3\n    ) +\n    geom_edge_link0(\n        aes(filter = (node1.lvl != node2.lvl)),\n        alpha = 0.3,\n        edge_linewidth = 0.1,\n        edge_colour = \"black\"\n    ) +\n    geom_edge_link0(\n        aes(filter = (node1.lvl == 2 &\n            node2.lvl == 2)),\n        edge_colour = \"goldenrod3\",\n        edge_linewidth = 0.3,\n        alpha = 0.5\n    ) +\n    geom_node_point(aes(shape = as.factor(lvl)), fill = \"grey25\", size = 3) +\n    scale_shape_manual(values = c(21, 22)) +\n    theme_graph() +\n    coord_cartesian(clip = \"off\", expand = TRUE) +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n11.4.0.2 Separate layouts for both levels\nIn many instances, there may be different structural properties inherent to the levels of the network. In that case, two layout functions can be passed to layout_as_multilevel() to deal with these differences. In our artificial network, level 1 has a hidden group structure and level 2 has a core-periphery structure.\nTo use this layout option, set type = \"separate\" and specify two layout functions with FUN1 and FUN2. You can change internal parameters of these layout functions with named lists in the params1 and params2 argument. Note that this version optimizes inter-level edges only minimally. The emphasis is on the intra-level structures.\n\nxy &lt;- layout_as_multilevel(multilvl_ex,\n    type = \"separate\",\n    FUN1 = layout_as_backbone,\n    FUN2 = layout_with_stress,\n    alpha = 25, beta = 45\n)\n\nAgain, try to include an edge geom for each level.\n\ncols2 &lt;- c(\n    \"#3A5FCD\", \"#CD00CD\", \"#EE30A7\", \"#EE6363\",\n    \"#CD2626\", \"#458B00\", \"#EEB422\", \"#EE7600\"\n)\n\nggraph(multilvl_ex, \"manual\", x = xy[, 1], y = xy[, 2]) +\n    geom_edge_link0(\n        aes(\n            filter = (node1.lvl == 1 & node2.lvl == 1),\n            edge_colour = col\n        ),\n        alpha = 0.5, edge_linewidth = 0.3\n    ) +\n    geom_edge_link0(\n        aes(filter = (node1.lvl != node2.lvl)),\n        alpha = 0.3,\n        edge_linewidth = 0.1,\n        edge_colour = \"black\"\n    ) +\n    geom_edge_link0(\n        aes(\n            filter = (node1.lvl == 2 & node2.lvl == 2),\n            edge_colour = col\n        ),\n        edge_linewidth = 0.3, alpha = 0.5\n    ) +\n    geom_node_point(aes(\n        fill = as.factor(grp),\n        shape = as.factor(lvl),\n        size = nsize\n    )) +\n    scale_shape_manual(values = c(21, 22)) +\n    scale_size_continuous(range = c(1.5, 4.5)) +\n    scale_fill_manual(values = cols2) +\n    scale_edge_color_manual(values = cols2, na.value = \"grey12\") +\n    scale_edge_alpha_manual(values = c(0.1, 0.7)) +\n    theme_graph() +\n    coord_cartesian(clip = \"off\", expand = TRUE) +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n11.4.0.3 Fix only one level\nThis layout can be used to emphasize one intra-level structure. The layout of the second level is calculated in a way that optimizes inter-level edge placement. Set type = \"fix1\" and specify FUN1 and possibly params1 to fix level 1 or set type = \"fix2\" and specify FUN2 and possibly params2 to fix level 2.\n\nxy &lt;- layout_as_multilevel(multilvl_ex,\n    type = \"fix2\",\n    FUN2 = layout_with_stress,\n    alpha = 25, beta = 45\n)\n\nggraph(multilvl_ex, \"manual\", x = xy[, 1], y = xy[, 2]) +\n    geom_edge_link0(\n        aes(\n            filter = (node1.lvl == 1 & node2.lvl == 1),\n            edge_colour = col\n        ),\n        alpha = 0.5, edge_linewidth = 0.3\n    ) +\n    geom_edge_link0(\n        aes(filter = (node1.lvl != node2.lvl)),\n        alpha = 0.3,\n        edge_linewidth = 0.1,\n        edge_colour = \"black\"\n    ) +\n    geom_edge_link0(\n        aes(\n            filter = (node1.lvl == 2 & node2.lvl == 2),\n            edge_colour = col\n        ),\n        edge_linewidth = 0.3, alpha = 0.5\n    ) +\n    geom_node_point(aes(\n        fill = as.factor(grp),\n        shape = as.factor(lvl),\n        size = nsize\n    )) +\n    scale_shape_manual(values = c(21, 22)) +\n    scale_size_continuous(range = c(1.5, 4.5)) +\n    scale_fill_manual(values = cols2) +\n    scale_edge_color_manual(values = cols2, na.value = \"grey12\") +\n    scale_edge_alpha_manual(values = c(0.1, 0.7)) +\n    theme_graph() +\n    coord_cartesian(clip = \"off\", expand = TRUE) +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n11.4.0.4 3D with threejs\nInstead of the default 2D projection, layout_as_multilevel() can also return the 3D layout by setting project2d = FALSE. The 3D layout can then be used with e.g. threejs to produce an interactive 3D visualization.\n\nlibrary(threejs)\nxyz &lt;- layout_as_multilevel(multilvl_ex,\n    type = \"separate\",\n    FUN1 = layout_as_backbone,\n    FUN2 = layout_with_stress,\n    project2D = FALSE\n)\nmultilvl_ex$layout &lt;- xyz\nV(multilvl_ex)$color &lt;- c(\"#00BFFF\", \"#FF69B4\")[V(multilvl_ex)$lvl]\nV(multilvl_ex)$vertex.label &lt;- V(multilvl_ex)$name\n\ngraphjs(multilvl_ex, bg = \"black\", vertex.shape = \"sphere\")",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Advanced Layouts</span>"
    ]
  },
  {
    "objectID": "further-viz.html",
    "href": "further-viz.html",
    "title": "12  Further reading",
    "section": "",
    "text": "The tutorial “Network Analysis and Visualization with R and igraph” by Katherine Ognyanova (link) comes with in-depth explanations of the built-in plotting function of igraph.\nFor further help on ggraph see the blog posts on layouts (link), nodes (link) and edges (link) by @thomasp85. Thomas is also the creator of tidygraph and there is also an introductory post on his blog (link).\nMore details and algorithms of the graphlayouts package can be found on my blog (link1, link2) and on the pkgdown page of graphlayouts.",
    "crumbs": [
      "Network Visualization",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Further reading</span>"
    ]
  },
  {
    "objectID": "tidygraph-intro.html",
    "href": "tidygraph-intro.html",
    "title": "13  Introduction",
    "section": "",
    "text": "13.1 Required libraries\nTo run all the code in this tutorial, you need to install and load two packages.\ntidygraph implements the tidy approach for network analysis. networkdata contains a diverse set of network dataset.\nlibrary(tidygraph)\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nlibrary(networkdata)\nMake sure you have at least the version given below. Some of the examples may not be backward compatible.\npackageVersion(\"tidygraph\")\n\n[1] '1.3.0'\n\npackageVersion(\"networkdata\")\n\n[1] '0.1.15'",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "tidygraph-intro.html#required-libraries",
    "href": "tidygraph-intro.html#required-libraries",
    "title": "13  Introduction",
    "section": "",
    "text": "install.packages(\"tidygraph\")\ndevtools::install_github(\"schochastics/networkdata\")",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "tidygraph-intro.html#what-is-tidy-network-data",
    "href": "tidygraph-intro.html#what-is-tidy-network-data",
    "title": "13  Introduction",
    "section": "13.2 What is tidy network data?",
    "text": "13.2 What is tidy network data?\nOn first glance, there is not much tidiness in networks or the ways it is usually encoded, like a graph, adjacency matrix, edgelist, etc. How should this fit into a single data frame? If you are an avid igraph user, then you may suspect the answer. It doesn’t fit, but it fits in two with graph_from_data_frame() which takes two data frames, one for nodes and one for edges, as input. In other words, we can represent a network as two separate data frames. One for the nodes and node attributes, and one for the edges and edge attributes. Working with these two data frames together is the premise for the tidygraph package. If you are interested in more technical details on how this is implemented under the hood, see the introductory blog post for the package.",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "tidygraph-intro.html#why-tidy-network-data",
    "href": "tidygraph-intro.html#why-tidy-network-data",
    "title": "13  Introduction",
    "section": "13.3 Why tidy network data?",
    "text": "13.3 Why tidy network data?\nThis is a good question. If you aren’t a fan of the tidyverse, then you should probably move along and stick with established packages such as igraph or sna which offer the exact same functionalities (tidygraph actually imports most of igraph). If you appreciate the tidyverse, then there is no need for convincing you that this is a good idea. If you are indifferent, then I hope I can make a case for the tidy framework below. To start off with, the package does a great job to harmonize many network analytic tasks. For instance, you do not need to know all the different centrality indices that are implemented. You simply type centrality_ and press tab in the RStudio console and get all functions that allow the calculation of a centrality index. Other node level functions are accessible via node_*() and edge level measures via edge_*().",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "tidygraph-basics.html",
    "href": "tidygraph-basics.html",
    "title": "14  Basics of tidygraph",
    "section": "",
    "text": "14.1 Graph structures\nWe’ll use the famous Florentine Family marriage dataset as a running example. The dataset is in igraph format but can be converted to a tbl_graph object with as_tbl_graph().\ndata(\"flo_marriage\")\nflo_tidy &lt;- as_tbl_graph(flo_marriage)\nflo_tidy\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\n\n\n# A tbl_graph: 16 nodes and 20 edges\n#\n# An undirected simple graph with 2 components\n#\n# Node Data: 16 × 4 (active)\n   name         wealth `#priors` `#ties`\n   &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n 1 Acciaiuoli       10        53       2\n 2 Albizzi          36        65       3\n 3 Barbadori        55         0      14\n 4 Bischeri         44        12       9\n 5 Castellani       20        22      18\n 6 Ginori           32         0       9\n 7 Guadagni          8        21      14\n 8 Lamberteschi     42         0      14\n 9 Medici          103        53      54\n10 Pazzi            48         0       7\n11 Peruzzi          49        42      32\n12 Pucci             3         0       1\n13 Ridolfi          27        38       4\n14 Salviati         10        35       5\n15 Strozzi         146        74      29\n16 Tornabuoni       48         0       7\n#\n# Edge Data: 20 × 2\n   from    to\n  &lt;int&gt; &lt;int&gt;\n1     1     9\n2     2     6\n3     2     7\n# ℹ 17 more rows\nThis new graph class just subclasses igraph and simply represents the network in a tidy fashion, printing two data frames, one for nodes and one for edges.\nclass(flo_tidy)\n\n[1] \"tbl_graph\" \"igraph\"\nAny function in R that expects an igraph object as input will also accept a tbl_graph.\nThe function tbl_graph() can be used to create a network from scratch with two data frames. It is basically equivalent to graph_from_data_frame().\nTo create random graphs with the usual generators, check out the create_*() and play_*() families of functions.",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Basics of tidygraph</span>"
    ]
  },
  {
    "objectID": "tidygraph-basics.html#standard-verbs",
    "href": "tidygraph-basics.html#standard-verbs",
    "title": "14  Basics of tidygraph",
    "section": "14.2 Standard verbs",
    "text": "14.2 Standard verbs\nThe tidy framework, specifically thinking about dplyr, is about providing verbs which help to solve common data manipulation tasks, such as mutate(), select(), filter(), and summarise(). The challange for the tbl_graph objects is that these verbs somehow need to work with two different data frames. The way tidygraph solves this is via a pointer to the data frame which is supposed to be manipulated. This pointer can be changed with the verb activate(). By default the nodes are activated, which can also be seen with the print function (see line 5 in the output of flo_tidy). To activate the edge data frame, simply use activate(\"edges\").\n\nflo_tidy %&gt;% activate(\"edges\")\n\n# A tbl_graph: 16 nodes and 20 edges\n#\n# An undirected simple graph with 2 components\n#\n# Edge Data: 20 × 2 (active)\n    from    to\n   &lt;int&gt; &lt;int&gt;\n 1     1     9\n 2     2     6\n 3     2     7\n 4     2     9\n 5     3     5\n 6     3     9\n 7     4     7\n 8     4    11\n 9     4    15\n10     5    11\n11     5    15\n12     7     8\n13     7    16\n14     9    13\n15     9    14\n16     9    16\n17    10    14\n18    11    15\n19    13    15\n20    13    16\n#\n# Node Data: 16 × 4\n  name       wealth `#priors` `#ties`\n  &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 Acciaiuoli     10        53       2\n2 Albizzi        36        65       3\n3 Barbadori      55         0      14\n# ℹ 13 more rows\n\n\nAny data manipulation would now be done on the edge data frame.\nHaving “activated” a data frame, many of the known dplyr verbs can be used to manipulate the data frame. The activation process might indicate that edges and nodes can only be manipulated separately, which is certainly not desirable. It is, however, possible to gain access to the edge data frame when nodes are activated via the .E(). Similarly, nodes can be accessed via .N() when edges are activated. In the below example, we activate the edges and create a new edge attribute which indicates if a family is connected to the Medici or not.\n\nflo_tidy &lt;- flo_tidy %&gt;% \n  activate(\"edges\") %&gt;% \n  mutate(to_medici=(.N()$name[from]==\"Medici\" | .N()$name[to]==\"Medici\"))\n\nThis particular use case is helpful for visualizations.\n\nggraph(flo_tidy, \"stress\") +\n    geom_edge_link0(aes(edge_color = to_medici)) +\n    geom_node_point(shape = 21, size = 10, fill = \"grey66\") +\n    geom_node_text(aes(label = name)) +\n    theme_graph()\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\n\nThe dplyr verb filter() can be used to obtain a subgraph that satisfies given conditions on the nodes. Note that in the case that you filter on nodes, also edges will be effected. If a node does not satisfy the condition, then all edges connected to that node disappear. This is not the case for edges though.\n\nflo_tidy %&gt;%\n    activate(\"edges\") %&gt;%\n    filter(to_medici) %&gt;%\n    ggraph(\"stress\", bbox = 10) +\n    geom_edge_link0(edge_color = \"black\") +\n    geom_node_point(shape = 21, size = 10, fill = \"grey66\") +\n    geom_node_text(aes(label = name)) +\n    theme_graph()",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Basics of tidygraph</span>"
    ]
  },
  {
    "objectID": "tidygraph-basics.html#joins",
    "href": "tidygraph-basics.html#joins",
    "title": "14  Basics of tidygraph",
    "section": "14.3 Joins",
    "text": "14.3 Joins",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Basics of tidygraph</span>"
    ]
  },
  {
    "objectID": "tidygraph-basics.html#new-verbs",
    "href": "tidygraph-basics.html#new-verbs",
    "title": "14  Basics of tidygraph",
    "section": "14.4 New Verbs",
    "text": "14.4 New Verbs",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Basics of tidygraph</span>"
    ]
  },
  {
    "objectID": "tidygraph-descriptive.html",
    "href": "tidygraph-descriptive.html",
    "title": "15  Descriptive Network Analysis",
    "section": "",
    "text": "15.1 Centrality\nThe package includes all centrality indices implemented in igraph and additionally all that are made available in the netrankr package. All indices can be found in the function group centrality_*().\nflo_tidy %&gt;%\n    activate(\"nodes\") %&gt;%\n    mutate(\n        degree = centrality_degree(),\n        betweenness = centrality_betweenness()\n    ) %&gt;%\n    ggraph(\"stress\", bbox = 10) +\n    geom_edge_link0(edge_color = \"black\") +\n    geom_node_point(shape = 21, aes(size = degree, fill = betweenness)) +\n    geom_node_text(aes(label = name)) +\n    scale_fill_gradient(low = \"#104E8B\", high = \"#CD2626\") +\n    scale_size(range = c(4, 10)) +\n    theme_graph()\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Descriptive Network Analysis</span>"
    ]
  },
  {
    "objectID": "tidygraph-descriptive.html#clustering",
    "href": "tidygraph-descriptive.html#clustering",
    "title": "15  Descriptive Network Analysis",
    "section": "15.2 Clustering",
    "text": "15.2 Clustering\nSimilar to centrality, all clustering algorithms from igraph are available via group_*()\n\n# create random graph with group structure (igraph equivalent is sample_islands())\nplay_islands(4, 12, 0.8, 4) %&gt;%\n    mutate(community = as.factor(group_louvain())) %&gt;%\n    ggraph(layout = \"stress\") +\n    geom_edge_link0() +\n    geom_node_point(aes(fill = community), shape = 21, size = 6) +\n    theme_graph()\n\n\n\n\n\n\n\n\nCoupling this with what we learned above, we can color the edges according to the cluster they belong to.\n\nplay_islands(4, 12, 0.8, 4) %&gt;%\n    mutate(community = as.factor(group_louvain())) %&gt;%\n    activate(\"edges\") %&gt;%\n    mutate(community = as.factor(ifelse(.N()$community[from] == .N()$community[to], .N()$community[from], 5))) %&gt;%\n    ggraph(layout = \"stress\") +\n    geom_edge_link0(aes(edge_colour = community), show.legend = FALSE) +\n    geom_node_point(aes(fill = community), shape = 21, size = 6) +\n    scale_fill_brewer(palette = \"Set3\") +\n    scale_edge_color_brewer(palette = \"Set3\") +\n    theme_graph(background = \"grey88\")",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Descriptive Network Analysis</span>"
    ]
  },
  {
    "objectID": "tidygraph-descriptive.html#other-node-or-edge-level-functions",
    "href": "tidygraph-descriptive.html#other-node-or-edge-level-functions",
    "title": "15  Descriptive Network Analysis",
    "section": "15.3 Other node or edge level functions",
    "text": "15.3 Other node or edge level functions\ntidygraphs harmonizes many other available functions in igraph to make them easier accessible. The best way to check what is available is to look at the function groups node_*() and edge_*(). Some simple examples are shown below.\n\n# the node id of the Medici is 9\nflo_tidy %&gt;%\n    activate(\"nodes\") %&gt;%\n    mutate(dist2Medici = node_distance_to(nodes = 9)) %&gt;%\n    activate(\"edges\") %&gt;%\n    mutate(edge2Medici = edge_is_incident(9)) %&gt;%\n    ggraph(\"stress\") +\n    geom_edge_link0(aes(edge_color = edge2Medici)) +\n    geom_node_point(aes(fill = dist2Medici), size = 9, shape = 21) +\n    theme_graph()",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Descriptive Network Analysis</span>"
    ]
  },
  {
    "objectID": "tidygraph-summary.html",
    "href": "tidygraph-summary.html",
    "title": "16  Summary",
    "section": "",
    "text": "The tidy framework works well in general but there are some shortcomings. So far, only basic network analytic methods are supported. This is enough for many tasks but as soon as more advanced techniques are needed, you are forced to switch to the “untidy” way again. A lot of coding but also conceptual work is needed to advance the framework further. For instance, how do ERGMs or SAOMs fit into this? Maybe there is a way to use tidymodels, but that is beyond the scope for now.\n\n17 Further Reading",
    "crumbs": [
      "Tidy Network Analysis",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "17  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]